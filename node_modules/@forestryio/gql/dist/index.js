"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __hasOwnProperty = Object.prototype.hasOwnProperty;
var __getOwnPropertySymbols = Object.getOwnPropertySymbols;
var __propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProperty.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropertySymbols) {
    for (var prop of __getOwnPropertySymbols(source))
      if (exclude.indexOf(prop) < 0 && __propertyIsEnumerable.call(source, prop))
        target[prop] = source[prop];
  }
  return target;
};

// src/gql/index.ts
const gql = {
  FormFieldBuilder: ({
    name,
    additionalFields
  }) => {
    return gql.ObjectTypeDefinition({
      name,
      interfaces: [gql.NamedType({name: "FormField"})],
      fields: [
        gql.FieldDefinition({name: "name", type: gql.TYPES.String}),
        gql.FieldDefinition({name: "label", type: gql.TYPES.String}),
        gql.FieldDefinition({name: "component", type: gql.TYPES.String}),
        ...additionalFields || []
      ]
    });
  },
  ScalarTypeDefinition: ({
    name,
    description
  }) => {
    return {
      kind: "ScalarTypeDefinition",
      name: {
        kind: "Name",
        value: name
      },
      description: {
        kind: "StringValue",
        value: description || ""
      },
      directives: []
    };
  },
  InputValueDefinition: ({
    name,
    type,
    list: list5,
    required
  }) => {
    let res = {};
    const namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    const def = {
      kind: "InputValueDefinition",
      name: {
        kind: "Name",
        value: name
      }
    };
    if (list5) {
      if (required) {
        res = __assign(__assign({}, def), {
          type: {
            kind: "ListType",
            type: {
              kind: "NonNullType",
              type: namedType
            }
          }
        });
      } else {
        res = __assign(__assign({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __assign(__assign({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __assign(__assign({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  FieldDefinition: ({
    name,
    type,
    args = [],
    list: list5,
    required
  }) => {
    let res = {};
    let namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    let def = {
      kind: "FieldDefinition",
      name: {
        kind: "Name",
        value: name
      },
      arguments: args
    };
    if (list5) {
      if (required) {
        res = __assign(__assign({}, def), {
          type: {
            kind: "ListType",
            type: {
              kind: "NonNullType",
              type: namedType
            }
          }
        });
      } else {
        res = __assign(__assign({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __assign(__assign({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __assign(__assign({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  InterfaceTypeDefinition: ({
    name,
    fields
  }) => {
    return {
      kind: "InterfaceTypeDefinition",
      name: {
        kind: "Name",
        value: name
      },
      interfaces: [],
      directives: [],
      fields
    };
  },
  InputObjectTypeDefinition: ({
    name,
    fields
  }) => ({
    kind: "InputObjectTypeDefinition",
    name: {
      kind: "Name",
      value: name
    },
    fields
  }),
  UnionTypeDefinition: ({
    name,
    types: types2
  }) => ({
    kind: "UnionTypeDefinition",
    name: {
      kind: "Name",
      value: name
    },
    directives: [],
    types: types2.map((name2) => ({
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name2
      }
    }))
  }),
  NamedType: ({name}) => {
    return {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name
      }
    };
  },
  ObjectTypeDefinition: ({
    name,
    fields,
    interfaces = [],
    args = []
  }) => ({
    kind: "ObjectTypeDefinition",
    interfaces,
    name: {
      kind: "Name",
      value: name
    },
    fields
  }),
  TYPES: {
    SectionDocumentUnion: "SectionDocumentUnion",
    String: "String",
    Reference: "Reference",
    Section: "Section",
    ID: "ID",
    SystemInfo: "SystemInfo",
    SectionParams: "SectionParams",
    Boolean: "Boolean",
    Node: "Node",
    Number: "Int",
    Document: "Document",
    JSONObject: "JSONObject"
  }
};

// src/util.ts
var _yup = require('yup'); var yup = _interopRequireWildcard(_yup);
const sequential = async (items, callback) => {
  const accum = [];
  const reducePromises = async (previous, endpoint) => {
    const prev = await previous;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
function assertShape(value, yupSchema) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    throw new Error(`Failed to assertShape - ${e.message}`);
  }
}

// src/fields/index.ts





function assertIsString(value, options) {
  if (typeof value !== "string") {
    throw new Error(`Unexpected value of type string for ${options.source}`);
  }
}
function assertIsBoolean(value, options) {
  if (typeof value !== "boolean") {
    throw new Error(`Unexpected value of type ${typeof value} for ${options.source}`);
  }
}
function assertIsNumber(value, options) {
  if (typeof value !== "number") {
    throw new Error(`Unexpected value of type ${typeof value} for ${options.source}`);
  }
}
function assertIsStringArray(value, options) {
  const schema = _yup.array.call(void 0, ).of(_yup.string.call(void 0, ));
  try {
    schema.validateSync(value);
  } catch (e) {
    console.log(value);
    throw new Error(`Unexpected array of strings for ${options.source} - ${e.message}`);
  }
}
function assertIsArray(value) {
  if (!Array.isArray(value)) {
    throw new Error("Expected an array for block input value");
  }
}
function assertIsBlockValueArray(value) {
  const schema = _yup.array.call(void 0, ).of(_yup.object.call(void 0, {
    template: _yup.string.call(void 0, ).required()
  }));
  try {
    schema.validateSync(value);
  } catch (e) {
    console.log(value);
    throw new Error(`Failed to assertIsBlockValueArray - ${e.message}`);
  }
}

// src/fields/text/index.ts
const typename = "TextField";
const text = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    value: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "text",
        config: rest2.config || {
          required: false
        },
        __typename: "TextField"
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsString(value, {source: "text initial value"});
      return value;
    },
    value: async ({value}) => {
      assertIsString(value, {source: "text value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsString(value, {source: "text input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/select/index.ts
var _graphqlhelpers = require('@forestryio/graphql-helpers');
const typename2 = "SelectField";
const select = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({
        name: typename2,
        additionalFields: [
          gql.FieldDefinition({
            name: "options",
            type: gql.TYPES.String,
            list: true
          })
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename2
      });
    },
    initialValue: async ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.Reference
      });
    },
    value: async ({cache: cache3, field, accumulator}) => {
      let select5;
      switch (field.config.source.type) {
        case "documents":
          throw new Error(`document select not implemented`);
        case "pages":
          select5 = field;
          const section = await cache3.datasource.getSettingsForCollection(select5.config.source.section);
          const name = _graphqlhelpers.friendlyName.call(void 0, section.slug);
          return gql.FieldDefinition({
            name: field.name,
            type: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Document"})
          });
        case "simple":
          return gql.FieldDefinition({
            name: field.name,
            type: gql.TYPES.String
          });
      }
    },
    input: async ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String
      });
    }
  },
  resolve: {
    field: async ({
      datasource,
      field
    }) => {
      let select5;
      const {type} = field, rest2 = __rest(field, ["type"]);
      const f = __assign(__assign({}, rest2), {
        component: "select",
        __typename: typename2
      });
      switch (field.config.source.type) {
        case "documents":
          throw new Error(`document select not implemented`);
        case "pages":
          select5 = field;
          return __assign(__assign({}, f), {
            options: [
              "",
              ...await datasource.getDocumentsForCollection(select5.config.source.section)
            ]
          });
        case "simple":
          select5 = field;
          return __assign(__assign({}, f), {
            options: ["", ...select5.config.options]
          });
      }
    },
    initialValue: async ({value}) => {
      return value;
    },
    value: async ({field, value}) => {
      switch (field.config.source.type) {
        case "documents":
          throw new Error(`document select not implemented`);
        case "pages":
          return {
            _resolver: "_resource",
            _resolver_kind: "_nested_source",
            _args: {fullPath: value, collection: field.config.source.section}
          };
        case "simple":
          return value;
      }
    },
    input: async ({field, value}) => {
      try {
        assertIsString(value, {source: "select input"});
        switch (field.config.source.type) {
          case "documents":
            throw new Error(`document select not implemented`);
          case "pages":
          case "simple":
            return {[field.name]: value};
        }
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/list/index.ts

const typename3 = "ListField";
const list = {
  imageGalleryField: (field) => __assign(__assign({}, field), {
    type: "list",
    config: {
      use_select: false
    }
  }),
  build: {
    field: async ({field, cache: cache3, accumulator}) => {
      text.build.field({
        cache: cache3,
        field: {name: "", label: "", type: "text", __namespace: ""},
        accumulator
      });
      select.build.field({
        cache: cache3,
        field: {
          name: "",
          label: "",
          type: "select",
          config: {
            options: [""],
            source: {
              type: "simple"
            }
          }
        },
        accumulator
      });
      const unionName = "List_FormFieldsUnion";
      accumulator.push(gql.UnionTypeDefinition({
        name: unionName,
        types: ["TextField", "SelectField"]
      }));
      accumulator.push(gql.FormFieldBuilder({
        name: typename3,
        additionalFields: [
          gql.FieldDefinition({
            name: "defaultItem",
            type: gql.TYPES.String
          }),
          gql.FieldDefinition({name: "field", type: unionName})
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename3
      });
    },
    initialValue: async ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    },
    value: async ({cache: cache3, field, accumulator}) => {
      var _a, _b, _c, _d;
      let listTypeIdentifier = "simple";
      listTypeIdentifier = ((_b = (_a = field.config) == null ? void 0 : _a.source) == null ? void 0 : _b.type) === "documents" ? "documents" : ((_d = (_c = field.config) == null ? void 0 : _c.source) == null ? void 0 : _d.type) === "pages" ? "pages" : "simple";
      let list5;
      switch (listTypeIdentifier) {
        case "documents":
          list5 = field;
          throw new Error(`document select not implemented`);
        case "pages":
          list5 = field;
          const section = await cache3.datasource.getSettingsForCollection(list5.config.source.section);
          return gql.FieldDefinition({
            name: field.name,
            type: _graphqlhelpers.friendlyName.call(void 0, section.slug, {suffix: "Document"}),
            list: true
          });
        case "simple":
          list5 = field;
          return gql.FieldDefinition({
            name: list5.name,
            type: gql.TYPES.String,
            list: true
          });
      }
    },
    input: async ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    }
  },
  resolve: {
    field: async ({
      datasource,
      field
    }) => {
      var _a, _b, _c, _d;
      const rest2 = __rest(field, []);
      let listTypeIdentifier = "simple";
      listTypeIdentifier = ((_b = (_a = field.config) == null ? void 0 : _a.source) == null ? void 0 : _b.type) === "documents" ? "documents" : ((_d = (_c = field.config) == null ? void 0 : _c.source) == null ? void 0 : _d.type) === "pages" ? "pages" : "simple";
      let defaultItem = "";
      let fieldComponent = {
        default: "",
        name: "",
        label: "Text",
        component: "text",
        __typename: "TextField"
      };
      let list5;
      switch (listTypeIdentifier) {
        case "documents":
          list5 = field;
          throw new Error(`document list not implemented`);
        case "pages":
          list5 = field;
          const selectField = __assign(__assign({}, list5), {
            component: "select",
            type: "select",
            __typename: "SelectField"
          });
          fieldComponent = await select.resolve.field({
            datasource,
            field: selectField
          });
          defaultItem = fieldComponent.options[0];
          break;
        case "simple":
          list5 = field;
          break;
      }
      return __assign(__assign({}, rest2), {
        component: "list",
        field: fieldComponent,
        defaultItem,
        __typename: typename3
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsStringArray(value, {source: "list initial values"});
      return value;
    },
    value: async ({
      field,
      value
    }) => {
      var _a, _b, _c, _d;
      assertIsStringArray(value, {source: "list values"});
      let listTypeIdentifier = "simple";
      listTypeIdentifier = ((_b = (_a = field.config) == null ? void 0 : _a.source) == null ? void 0 : _b.type) === "documents" ? "documents" : ((_d = (_c = field.config) == null ? void 0 : _c.source) == null ? void 0 : _d.type) === "pages" ? "pages" : "simple";
      let list5;
      switch (listTypeIdentifier) {
        case "documents":
          list5 = field;
          throw new Error(`document list not implemented`);
        case "pages":
          list5 = field;
          return {
            _resolver: "_resource",
            _resolver_kind: "_nested_sources",
            _args: {
              fullPaths: value,
              collection: list5.config.source.section
            }
          };
        case "simple":
          list5 = field;
          return value;
      }
    },
    input: async ({
      field,
      value
    }) => {
      var _a, _b, _c, _d;
      try {
        assertIsStringArray(value, {source: "list input"});
        let listTypeIdentifier = "simple";
        const isSimple = field.config.use_select ? false : true;
        if (!isSimple) {
          listTypeIdentifier = ((_b = (_a = field.config) == null ? void 0 : _a.source) == null ? void 0 : _b.type) === "documents" ? "documents" : ((_d = (_c = field.config) == null ? void 0 : _c.source) == null ? void 0 : _d.type) === "pages" ? "pages" : "simple";
        }
        let list5;
        switch (listTypeIdentifier) {
          case "documents":
            list5 = field;
            throw new Error(`document list not implemented`);
          case "pages":
            return {[field.name]: value};
          case "simple":
            list5 = field;
            return {[field.name]: value};
        }
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/blocks/index.ts

const blocks = {
  build: {
    field: async ({cache: cache3, field, accumulator}) => {
      const typename10 = _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "BlocksField"});
      const templateName = _graphqlhelpers.friendlyName.call(void 0, field, {
        suffix: "BlocksFieldTemplates"
      });
      accumulator.push(gql.ObjectTypeDefinition({
        name: templateName,
        fields: await sequential(field.template_types, async (templateSlug) => {
          const t = await cache3.datasource.getTemplate(templateSlug);
          await template.build.form({
            cache: cache3,
            template: t,
            accumulator,
            includeBody: false
          });
          return gql.FieldDefinition({
            name: _graphqlhelpers.friendlyName.call(void 0, t, {lowerCase: true}),
            type: _graphqlhelpers.friendlyName.call(void 0, t, {suffix: "Form"})
          });
        })
      }));
      accumulator.push(gql.FormFieldBuilder({
        name: typename10,
        additionalFields: [
          gql.FieldDefinition({name: "templates", type: templateName})
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename10
      });
    },
    initialValue: async ({cache: cache3, field, accumulator}) => {
      const name = _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "Values"});
      await sequential(field.template_types, async (templateSlug) => {
        const t = await cache3.datasource.getTemplate(templateSlug);
        await template.build.values({
          cache: cache3,
          template: t,
          accumulator,
          includeBody: false
        });
      });
      accumulator.push(gql.UnionTypeDefinition({
        name,
        types: field.template_types.map((t) => _graphqlhelpers.friendlyName.call(void 0, t, {suffix: "Values"}))
      }));
      return gql.FieldDefinition({name: field.name, type: name, list: true});
    },
    value: async ({cache: cache3, field, accumulator}) => {
      const fieldUnionName = _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "Data"});
      await sequential(field.template_types, async (templateSlug) => {
        const t = await cache3.datasource.getTemplate(templateSlug);
        await template.build.data({
          cache: cache3,
          template: t,
          accumulator,
          includeBody: false
        });
      });
      accumulator.push(gql.UnionTypeDefinition({
        name: fieldUnionName,
        types: field.template_types.map((t) => _graphqlhelpers.friendlyName.call(void 0, t, {suffix: "Data"}))
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: fieldUnionName,
        list: true
      });
    },
    input: async ({cache: cache3, field, accumulator}) => {
      await sequential(field.template_types, async (templateSlug) => {
        const t = await cache3.datasource.getTemplate(templateSlug);
        await template.build.input({
          cache: cache3,
          template: t,
          accumulator,
          includeBody: false
        });
      });
      accumulator.push(gql.InputObjectTypeDefinition({
        name: _graphqlhelpers.friendlyName.call(void 0, field.name, {suffix: "Input"}),
        fields: field.template_types.map((template2) => gql.InputValueDefinition({
          name: _graphqlhelpers.friendlyName.call(void 0, template2, {lowerCase: true}),
          type: _graphqlhelpers.templateTypeName.call(void 0, template2, "Input", false)
        }))
      }));
      return gql.InputValueDefinition({
        name: field.name,
        type: _graphqlhelpers.friendlyName.call(void 0, field.name, {suffix: "Input"}),
        list: true
      });
    }
  },
  resolve: {
    field: async ({datasource, field}) => {
      const templates5 = {};
      await sequential(field.template_types, async (templateSlug) => {
        const t = await datasource.getTemplate(templateSlug);
        templates5[_graphqlhelpers.friendlyName.call(void 0, templateSlug, {lowerCase: true})] = await template.resolve.form({
          datasource,
          template: t
        });
      });
      return __assign(__assign({}, field), {
        component: "blocks",
        templates: templates5,
        __typename: _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "BlocksField"})
      });
    },
    initialValue: async ({datasource, value}) => {
      assertIsBlockValueArray(value);
      return await sequential(value, async (item) => {
        const templateData = await datasource.getTemplate(item.template);
        const itemValue = await template.resolve.values({
          datasource,
          template: templateData,
          data: item
        });
        return __assign(__assign({}, itemValue), {
          _template: _graphqlhelpers.friendlyName.call(void 0, itemValue._template, {lowerCase: true})
        });
      });
    },
    value: async ({datasource, value}) => {
      assertIsBlockValueArray(value);
      return await sequential(value, async (item) => {
        const templateData = await datasource.getTemplate(item.template);
        const data = await template.resolve.data({
          datasource,
          template: templateData,
          data: item
        });
        return __assign({template: item.template}, data);
      });
    },
    input: async ({field, datasource, value}) => {
      try {
        assertIsArray(value);
      } catch (e) {
        return false;
      }
      const accum = (await sequential(value, async (item) => {
        try {
          assertShape(item, (yup5) => yup5.object({}));
          const key = Object.keys(item)[0];
          const data = Object.values(item)[0];
          const resolvedData = await template.resolve.input({
            data,
            template: await datasource.getTemplate(key),
            datasource
          });
          return __assign({
            template: key
          }, resolvedData);
        } catch (e) {
          console.log(e);
          return false;
        }
      })).filter(Boolean);
      if (accum.length > 0) {
        return {[field.name]: accum};
      } else {
        return false;
      }
    }
  }
};

// src/fields/textarea/index.ts
const typename4 = "TextareaField";
const textarea = {
  contentField: {
    type: "textarea",
    name: "_body",
    label: "Body",
    __namespace: ""
  },
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename4}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename4
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    value: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "textarea",
        config: rest2.config || {
          required: false
        },
        __typename: "TextareaField"
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsString(value, {source: "textarea initial value"});
      return value;
    },
    value: async ({value}) => {
      assertIsString(value, {source: "textarea value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsString(value, {source: "textarea input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/field-group/index.ts




const fieldGroup = {
  build: {
    field: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const typename10 = _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "GroupField"});
      const fieldsUnionName = await template.build.fields({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      accumulator.push(gql.FormFieldBuilder({
        name: typename10,
        additionalFields: [
          gql.FieldDefinition({
            name: "fields",
            type: fieldsUnionName,
            list: true
          })
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename10
      });
    },
    initialValue: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const initialValueName = await template.build.values({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false,
        includeTemplate: false
      });
      return gql.FieldDefinition({name: field.name, type: initialValueName});
    },
    value: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const name = await template.build.data({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      return gql.FieldDefinition({name: field.name, type: name});
    },
    input: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const name = await template.build.input({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      return gql.InputValueDefinition({name: field.name, type: name});
    }
  },
  resolve: {
    field: async ({
      datasource,
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      const t = await template.resolve.form({
        datasource,
        template: field,
        includeBody: false
      });
      return __assign(__assign(__assign({}, rest2), t), {
        component: "group",
        __typename: _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "GroupField"})
      });
    },
    initialValue: async ({
      datasource,
      field,
      value
    }) => {
      assertIsData(value);
      return await template.resolve.values({
        datasource,
        template: field,
        data: value
      });
    },
    value: async ({
      datasource,
      field,
      value
    }) => {
      assertIsData(value);
      return await template.resolve.data({
        datasource,
        template: field,
        data: value
      });
    },
    input: async ({
      datasource,
      field,
      value
    }) => {
      try {
        assertIsData(value);
        return {
          [field.name]: await template.resolve.input({
            data: value,
            template: field,
            datasource
          })
        };
      } catch (e) {
        return false;
      }
    }
  }
};
function assertIsData(value) {
  const schema = _yup.object.call(void 0, {}).required();
  schema.validateSync(value);
}

// src/fields/field-group-list/index.ts





const fieldGroupList = {
  build: {
    field: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const typename10 = _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "GroupListField"});
      const fieldsUnionName = await template.build.fields({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      accumulator.push(gql.FormFieldBuilder({
        name: typename10,
        additionalFields: [
          gql.FieldDefinition({
            name: "fields",
            type: fieldsUnionName,
            list: true
          })
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename10
      });
    },
    initialValue: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const initialValueName = await template.build.values({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false,
        includeTemplate: false
      });
      return gql.FieldDefinition({
        name: field.name,
        type: initialValueName,
        list: true
      });
    },
    value: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const name = await template.build.data({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      return gql.FieldDefinition({
        name: field.name,
        type: name,
        list: true
      });
    },
    input: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      const name = await template.build.input({
        cache: cache3,
        template: field,
        accumulator,
        includeBody: false
      });
      return gql.InputValueDefinition({
        name: field.name,
        type: name,
        list: true
      });
    }
  },
  resolve: {
    field: async ({
      datasource,
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      const t = await template.resolve.form({
        datasource,
        template: field,
        includeBody: false
      });
      return __assign(__assign(__assign({}, rest2), t), {
        component: "group-list",
        __typename: _graphqlhelpers.friendlyName.call(void 0, field, {suffix: "GroupListField"})
      });
    },
    initialValue: async ({
      datasource,
      field,
      value
    }) => {
      assertIsDataArray(value);
      return sequential(value, async (v) => await template.resolve.values({
        datasource,
        template: field,
        data: v
      }));
    },
    value: async ({
      datasource,
      field,
      value
    }) => {
      assertIsDataArray(value);
      return await sequential(value, async (v) => await template.resolve.data({
        datasource,
        template: field,
        data: v
      }));
    },
    input: async ({
      datasource,
      field,
      value
    }) => {
      try {
        assertIsDataArray(value);
        const values = await sequential(value, async (v) => {
          return await template.resolve.input({
            data: v,
            template: field,
            datasource
          });
        });
        if (values && values.length > 0) {
          return {
            [field.name]: values
          };
        } else {
          return false;
        }
      } catch (e) {
        return false;
      }
    }
  }
};
function assertIsDataArray(value) {
  const schema = _yup.array.call(void 0, ).of(_yup.object.call(void 0, {}));
  schema.validateSync(value);
}

// src/fields/boolean/index.ts
const typename5 = "BooleanField";
const boolean = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename5}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename5
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.Boolean});
    },
    value: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.Boolean});
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.Boolean
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "toggle",
        config: rest2.config || {
          required: false
        },
        __typename: "BooleanField"
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsBoolean(value, {source: "boolean initial value"});
      return value;
    },
    value: async ({value}) => {
      assertIsBoolean(value, {source: "boolean value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsBoolean(value, {source: "boolean input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/datetime/index.ts
var _isValid = require('date-fns/isValid'); var _isValid2 = _interopRequireDefault(_isValid);
var _parseISO = require('date-fns/parseISO'); var _parseISO2 = _interopRequireDefault(_parseISO);
var _format = require('date-fns/format'); var _format2 = _interopRequireDefault(_format);
const typename6 = "DatetimeField";
const DEFAULT_DATE_FORMAT = "MMM dd, yyyy";
const datetime = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({
        name: typename6,
        additionalFields: [
          gql.FieldDefinition({
            name: "dateFormat",
            type: gql.TYPES.String
          }),
          gql.FieldDefinition({
            name: "timeFormat",
            type: gql.TYPES.String
          })
        ]
      }));
      return gql.FieldDefinition({
        name: field.name,
        type: typename6
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    value: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "date",
        __typename: typename6,
        config: rest2.config || {
          required: false
        }
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsString(value, {source: "datetime"});
      return value;
    },
    value: async ({value}) => {
      assertIsString(value, {source: "datetime"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsString(value, {source: "datetime"});
        const date = _parseISO2.default.call(void 0, value);
        if (!_isValid2.default.call(void 0, date)) {
          throw "Invalid Date";
        }
        const dateUTC = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1e3);
        const dateFormat = field.dateFormat || DEFAULT_DATE_FORMAT;
        const fixedDateFormat = dateFormat.replace(/D/g, "d").replace(/Y/g, "y");
        const timeFormat = field.timeFormat || false;
        const datePart = _format2.default.call(void 0, dateUTC, fixedDateFormat);
        const timePart = timeFormat ? ` ${_format2.default.call(void 0, dateUTC, timeFormat)}` : "";
        return {[field.name]: `${datePart}${timePart}`};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/file/index.ts
const typename7 = "FileField";
const file = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename7}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename7
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    value: ({field}) => {
      return gql.FieldDefinition({name: field.name, type: gql.TYPES.String});
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "image",
        __typename: typename7,
        config: rest2.config || {
          required: false
        }
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsString(value, {source: "file initial value"});
      return value;
    },
    value: async ({value}) => {
      assertIsString(value, {source: "file value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsString(value, {source: "file input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/image-gallery/index.ts
const imageGallery = {
  build: {
    field: async ({
      cache: cache3,
      field,
      accumulator
    }) => {
      return list.build.field({
        cache: cache3,
        field: list.imageGalleryField(field),
        accumulator
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    },
    value: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    }
  },
  resolve: {
    field: async ({
      datasource,
      field
    }) => {
      return await list.resolve.field({
        datasource,
        field: list.imageGalleryField(field)
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsStringArray(value, {source: "image gallery initial value"});
      return value;
    },
    value: async ({
      value
    }) => {
      assertIsStringArray(value, {source: "image gallery value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsStringArray(value, {source: "image gallery input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/number/index.ts
const typename8 = "NumberField";
const number = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename8}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename8
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.Number
      });
    },
    value: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.Number
      });
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.Number
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "number",
        config: rest2.config || {
          required: false
        },
        __typename: typename8
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsNumber(value, {source: "number field initial value"});
      return value;
    },
    value: async ({value}) => {
      assertIsNumber(value, {source: "number field value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsNumber(value, {source: "number field input"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/tag-list/index.ts
const typename9 = "TagListField";
const tag_list = {
  build: {
    field: async ({field, accumulator}) => {
      accumulator.push(gql.FormFieldBuilder({name: typename9}));
      return gql.FieldDefinition({
        name: field.name,
        type: typename9
      });
    },
    initialValue: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    },
    value: ({field}) => {
      return gql.FieldDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    },
    input: ({field}) => {
      return gql.InputValueDefinition({
        name: field.name,
        type: gql.TYPES.String,
        list: true
      });
    }
  },
  resolve: {
    field: ({
      field
    }) => {
      const {type} = field, rest2 = __rest(field, ["type"]);
      return __assign(__assign({}, rest2), {
        component: "tags",
        config: rest2.config || {
          required: false
        },
        __typename: typename9
      });
    },
    initialValue: async ({
      value
    }) => {
      assertIsStringArray(value, {source: "tag value"});
      return value;
    },
    value: async ({value}) => {
      assertIsStringArray(value, {source: "tag value"});
      return value;
    },
    input: async ({
      field,
      value
    }) => {
      try {
        assertIsStringArray(value, {source: "tag value"});
        return {[field.name]: value};
      } catch (e) {
        return false;
      }
    }
  }
};

// src/fields/templates/build.ts
var _lodash = require('lodash'); var _lodash2 = _interopRequireDefault(_lodash);

const buildTemplateOrFieldData = async ({
  cache: cache3,
  template: template2,
  accumulator,
  includeBody
}) => {
  const name = _graphqlhelpers.templateTypeName.call(void 0, template2, "Data", includeBody);
  const fields = await sequential(template2.fields, async (field) => {
    return await buildTemplateDataField(cache3, field, accumulator);
  });
  if (includeBody) {
    fields.push(await buildTemplateDataField(cache3, textarea.contentField, accumulator));
  }
  accumulator.push(gql.ObjectTypeDefinition({
    name,
    fields
  }));
  return name;
};
const buildTemplateOrFieldValues = async ({
  cache: cache3,
  template: template2,
  accumulator,
  includeBody,
  includeTemplate = true
}) => {
  const name = _graphqlhelpers.templateTypeName.call(void 0, template2, "Values", includeBody);
  const fields = await sequential(template2.fields, async (field) => {
    return buildTemplateInitialValueField(cache3, field, accumulator);
  });
  if (includeBody) {
    fields.push(await buildTemplateInitialValueField(cache3, textarea.contentField, accumulator));
  }
  if (includeTemplate) {
    fields.push(gql.FieldDefinition({name: "_template", type: gql.TYPES.String}));
  }
  accumulator.push(gql.ObjectTypeDefinition({
    name,
    fields
  }));
  return name;
};
const buildTemplateOrFieldFormFields = async ({
  cache: cache3,
  template: template2,
  accumulator,
  includeBody
}) => {
  const name = _graphqlhelpers.templateTypeName.call(void 0, template2, "Form", includeBody);
  const fields = await sequential(template2.fields, async (field) => await buildTemplateFormField(cache3, field, accumulator));
  if (includeBody) {
    fields.push(await buildTemplateFormField(cache3, textarea.contentField, accumulator));
  }
  const fieldsUnionName = `${name}FieldsUnion`;
  accumulator.push(gql.UnionTypeDefinition({
    name: fieldsUnionName,
    types: _lodash2.default.uniq(fields.map((field) => {
      switch (field.type.kind) {
        case "NamedType":
          return field.type.name.value;
        case "ListType":
        case "NonNullType":
          throw new Error(`Unexpected ${field.type.kind} for field union field`);
      }
    }))
  }));
  return fieldsUnionName;
};
const buildTemplateOrFieldInput = async ({
  cache: cache3,
  template: template2,
  accumulator,
  includeBody
}) => {
  const name = _graphqlhelpers.templateTypeName.call(void 0, template2, "Input", includeBody);
  const fields = await sequential(template2.fields, async (field) => await buildTemplateInputDataField(cache3, field, accumulator));
  if (includeBody) {
    fields.push(await buildTemplateInputDataField(cache3, textarea.contentField, accumulator));
  }
  accumulator.push(gql.InputObjectTypeDefinition({
    name,
    fields
  }));
  return name;
};
const buildTemplateOrFieldForm = async ({
  cache: cache3,
  template: template2,
  accumulator,
  includeBody,
  nameOverride
}) => {
  const name = nameOverride || _graphqlhelpers.templateTypeName.call(void 0, template2, "Form", includeBody);
  const fieldsUnionName = await buildTemplateOrFieldFormFields({
    cache: cache3,
    template: template2,
    accumulator,
    includeBody
  });
  accumulator.push(gql.ObjectTypeDefinition({
    name,
    fields: [
      gql.FieldDefinition({name: "label", type: `String`}),
      gql.FieldDefinition({name: "name", type: `String`}),
      gql.FieldDefinition({
        name: "fields",
        type: fieldsUnionName,
        list: true
      })
    ]
  }));
  return name;
};
const buildTemplateFormField = async (cache3, field, accumulator) => {
  switch (field.type) {
    case "text":
      return text.build.field({cache: cache3, field, accumulator});
    case "textarea":
      return textarea.build.field({cache: cache3, field, accumulator});
    case "select":
      return select.build.field({cache: cache3, field, accumulator});
    case "blocks":
      return blocks.build.field({cache: cache3, field, accumulator});
    case "field_group_list":
      return fieldGroupList.build.field({cache: cache3, field, accumulator});
    case "field_group":
      return fieldGroup.build.field({cache: cache3, field, accumulator});
    case "list":
      return list.build.field({cache: cache3, field, accumulator});
    case "boolean":
      return boolean.build.field({cache: cache3, field, accumulator});
    case "datetime":
      return datetime.build.field({cache: cache3, field, accumulator});
    case "file":
      return file.build.field({cache: cache3, field, accumulator});
    case "image_gallery":
      return imageGallery.build.field({cache: cache3, field, accumulator});
    case "number":
      return number.build.field({cache: cache3, field, accumulator});
    case "tag_list":
      return tag_list.build.field({cache: cache3, field, accumulator});
    default:
      return text.build.field({cache: cache3, field, accumulator});
  }
};
const buildTemplateInitialValueField = async (cache3, field, accumulator) => {
  switch (field.type) {
    case "text":
      return text.build.initialValue({cache: cache3, field, accumulator});
    case "textarea":
      return textarea.build.initialValue({cache: cache3, field, accumulator});
    case "select":
      return await select.build.initialValue({cache: cache3, field, accumulator});
    case "blocks":
      return blocks.build.initialValue({cache: cache3, field, accumulator});
    case "field_group":
      return fieldGroup.build.initialValue({cache: cache3, field, accumulator});
    case "field_group_list":
      return fieldGroupList.build.initialValue({cache: cache3, field, accumulator});
    case "list":
      return list.build.initialValue({cache: cache3, field, accumulator});
    case "boolean":
      return boolean.build.initialValue({cache: cache3, field, accumulator});
    case "datetime":
      return datetime.build.initialValue({cache: cache3, field, accumulator});
    case "file":
      return file.build.initialValue({cache: cache3, field, accumulator});
    case "image_gallery":
      return imageGallery.build.initialValue({cache: cache3, field, accumulator});
    case "number":
      return number.build.initialValue({cache: cache3, field, accumulator});
    case "tag_list":
      return tag_list.build.initialValue({cache: cache3, field, accumulator});
    default:
      return text.build.initialValue({cache: cache3, field, accumulator});
  }
};
const buildTemplateDataField = async (cache3, field, accumulator) => {
  switch (field.type) {
    case "text":
      return text.build.value({cache: cache3, field, accumulator});
    case "textarea":
      return textarea.build.value({cache: cache3, field, accumulator});
    case "select":
      return await select.build.value({cache: cache3, field, accumulator});
    case "blocks":
      return blocks.build.value({cache: cache3, field, accumulator});
    case "field_group":
      return await fieldGroup.build.value({cache: cache3, field, accumulator});
    case "field_group_list":
      return fieldGroupList.build.value({cache: cache3, field, accumulator});
    case "list":
      return list.build.value({cache: cache3, field, accumulator});
    case "boolean":
      return boolean.build.value({cache: cache3, field, accumulator});
    case "datetime":
      return datetime.build.value({cache: cache3, field, accumulator});
    case "file":
      return file.build.value({cache: cache3, field, accumulator});
    case "image_gallery":
      return imageGallery.build.value({cache: cache3, field, accumulator});
    case "number":
      return number.build.value({cache: cache3, field, accumulator});
    case "tag_list":
      return tag_list.build.value({cache: cache3, field, accumulator});
    default:
      return text.build.value({cache: cache3, field, accumulator});
  }
};
const buildTemplateInputDataField = async (cache3, field, accumulator) => {
  switch (field.type) {
    case "text":
      return text.build.input({cache: cache3, field, accumulator});
    case "textarea":
      return textarea.build.input({cache: cache3, field, accumulator});
    case "select":
      return select.build.input({cache: cache3, field, accumulator});
    case "blocks":
      return await blocks.build.input({cache: cache3, field, accumulator});
    case "field_group":
      return fieldGroup.build.input({cache: cache3, field, accumulator});
    case "field_group_list":
      return fieldGroupList.build.input({cache: cache3, field, accumulator});
    case "list":
      return list.build.input({cache: cache3, field, accumulator});
    case "boolean":
      return boolean.build.input({cache: cache3, field, accumulator});
    case "datetime":
      return datetime.build.input({cache: cache3, field, accumulator});
    case "file":
      return file.build.input({cache: cache3, field, accumulator});
    case "image_gallery":
      return imageGallery.build.input({cache: cache3, field, accumulator});
    case "number":
      return number.build.input({cache: cache3, field, accumulator});
    case "tag_list":
      return tag_list.build.input({cache: cache3, field, accumulator});
    default:
      return text.build.input({cache: cache3, field, accumulator});
  }
};
const builder = {
  form: buildTemplateOrFieldForm,
  fields: buildTemplateOrFieldFormFields,
  data: buildTemplateOrFieldData,
  values: buildTemplateOrFieldValues,
  input: buildTemplateOrFieldInput
};

// src/fields/templates/resolver.ts

const resolve = {
  data: async ({datasource, template: template2, data, content}) => {
    const accum = {};
    const {template: _templateName} = data, rest2 = __rest(data, ["template"]);
    const values = content ? __assign(__assign({}, rest2), {_body: content}) : rest2;
    await sequential(Object.keys(values), async (key) => {
      const field = findField([...template2.fields, textarea.contentField], key, template2);
      return accum[key] = await dataValue(datasource, field, values[key]);
    });
    return __assign({
      __typename: _graphqlhelpers.templateTypeName.call(void 0, template2, "Data", typeof content !== "undefined")
    }, accum);
  },
  values: async ({datasource, template: template2, data, content}) => {
    const accum = {};
    const {template: _templateName} = data, rest2 = __rest(data, ["template"]);
    const values = content ? __assign(__assign({}, rest2), {_body: content}) : rest2;
    await sequential(Object.keys(values), async (key) => {
      const field = findField([...template2.fields, textarea.contentField], key, template2);
      return accum[key] = await dataInitialValuesField(datasource, field, values[key]);
    });
    return __assign({
      __typename: _graphqlhelpers.templateTypeName.call(void 0, template2, "Values", typeof content !== "undefined"),
      _template: template2.name
    }, accum);
  },
  form: async ({
    datasource,
    template: template2,
    includeBody
  }) => {
    const fields = await sequential(template2.fields, async (field) => dataField(datasource, field));
    if (includeBody) {
      fields.push(await textarea.resolve.field({
        datasource,
        field: textarea.contentField
      }));
    }
    return __assign(__assign({}, template2), {
      __typename: _graphqlhelpers.templateTypeName.call(void 0, template2, "Form", !!includeBody),
      fields
    });
  },
  input: async ({
    datasource,
    data,
    includeBody,
    template: template2
  }) => {
    if (includeBody) {
      template2.fields.push(textarea.contentField);
    }
    if (includeBody) {
      assertShape(data, (yup5) => yup5.object({_template: yup5.string().required()}));
    } else {
      assertShape(data, (yup5) => yup5.object());
    }
    const fieldsToWrite = await sequential(template2.fields, async (field) => {
      return inputField({
        datasource,
        field,
        value: data[field.name]
      });
    });
    if (includeBody) {
      fieldsToWrite.push({_template: data._template});
    }
    const accum = {};
    fieldsToWrite.filter(Boolean).forEach((item) => {
      assertShape(item, (yup5) => yup5.object());
      const key = Object.keys(item)[0];
      const value = Object.values(item)[0];
      accum[key] = value;
    });
    return accum;
  }
};
const dataInitialValuesField = async (datasource, field, value) => {
  switch (field.type) {
    case "text":
      return text.resolve.initialValue({datasource, field, value});
    case "textarea":
      return textarea.resolve.initialValue({datasource, field, value});
    case "blocks":
      return blocks.resolve.initialValue({datasource, field, value});
    case "select":
      return select.resolve.initialValue({datasource, field, value});
    case "list":
      return list.resolve.initialValue({datasource, field, value});
    case "field_group":
      return fieldGroup.resolve.initialValue({datasource, field, value});
    case "field_group_list":
      return fieldGroupList.resolve.initialValue({datasource, field, value});
    case "boolean":
      return boolean.resolve.initialValue({datasource, field, value});
    case "datetime":
      return datetime.resolve.initialValue({datasource, field, value});
    case "file":
      return file.resolve.initialValue({datasource, field, value});
    case "image_gallery":
      return imageGallery.resolve.initialValue({datasource, field, value});
    case "number":
      return number.resolve.initialValue({datasource, field, value});
    case "tag_list":
      return tag_list.resolve.initialValue({datasource, field, value});
  }
};
const dataValue = async (datasource, field, value) => {
  switch (field.type) {
    case "text":
      return text.resolve.value({datasource, field, value});
    case "textarea":
      return textarea.resolve.value({datasource, field, value});
    case "blocks":
      return blocks.resolve.value({datasource, field, value});
    case "select":
      return select.resolve.value({datasource, field, value});
    case "list":
      return list.resolve.value({datasource, field, value});
    case "field_group":
      return fieldGroup.resolve.value({datasource, field, value});
    case "field_group_list":
      return fieldGroupList.resolve.value({
        datasource,
        field,
        value
      });
    case "boolean":
      return boolean.resolve.value({datasource, field, value});
    case "datetime":
      return datetime.resolve.value({datasource, field, value});
    case "file":
      return file.resolve.value({datasource, field, value});
    case "image_gallery":
      return imageGallery.resolve.value({datasource, field, value});
    case "number":
      return number.resolve.value({datasource, field, value});
    case "tag_list":
      return tag_list.resolve.value({datasource, field, value});
  }
};
const dataField = async (datasource, field) => {
  switch (field.type) {
    case "text":
      return text.resolve.field({datasource, field});
    case "textarea":
      return textarea.resolve.field({datasource, field});
    case "blocks":
      return blocks.resolve.field({datasource, field});
    case "select":
      return select.resolve.field({datasource, field});
    case "list":
      return list.resolve.field({datasource, field});
    case "field_group":
      return fieldGroup.resolve.field({datasource, field});
    case "field_group_list":
      return fieldGroupList.resolve.field({
        datasource,
        field
      });
    case "boolean":
      return boolean.resolve.field({datasource, field});
    case "datetime":
      return datetime.resolve.field({datasource, field});
    case "file":
      return file.resolve.field({datasource, field});
    case "image_gallery":
      return imageGallery.resolve.field({datasource, field});
    case "number":
      return number.resolve.field({datasource, field});
    case "tag_list":
      return tag_list.resolve.field({datasource, field});
  }
};
const inputField = async ({
  datasource,
  field,
  value
}) => {
  switch (field.type) {
    case "text":
      return text.resolve.input({datasource, field, value});
    case "textarea":
      return textarea.resolve.input({datasource, field, value});
    case "blocks":
      return blocks.resolve.input({datasource, field, value});
    case "select":
      return select.resolve.input({datasource, field, value});
    case "list":
      return list.resolve.input({datasource, field, value});
    case "field_group":
      return fieldGroup.resolve.input({datasource, field, value});
    case "field_group_list":
      return fieldGroupList.resolve.input({datasource, field, value});
    case "boolean":
      return boolean.resolve.input({datasource, field, value});
    case "datetime":
      return datetime.resolve.input({datasource, field, value});
    case "file":
      return file.resolve.input({datasource, field, value});
    case "image_gallery":
      return imageGallery.resolve.input({datasource, field, value});
    case "number":
      return number.resolve.input({datasource, field, value});
    case "tag_list":
      return tag_list.resolve.input({datasource, field, value});
  }
};
const findField = (fields, fieldName, template2) => {
  const field = fields.find((f) => {
    return (f == null ? void 0 : f.name) === fieldName;
  });
  if (!field) {
    throw new Error(`Unable to find field for item with name: ${fieldName} on template ${template2.name} Possible fields are: ${template2.fields.map((field2) => field2.name).join(", ")}
      `);
  }
  return field;
};

// src/fields/templates/index.ts
const template = {
  build: builder,
  resolve
};

// src/builder/index.ts


const schemaBuilder = async ({cache: cache3}) => {
  const sectionMap = {};
  const mutationsArray = [];
  const sections = await cache3.datasource.getCollectionsSettings();
  sections.forEach((section) => {
    buildSectionMap(section, mutationsArray, sectionMap);
  });
  const accumulator = [
    ...interfaceDefinitions,
    ...scalarDefinitions,
    systemInfoDefinition,
    sectionDefinition,
    gql.UnionTypeDefinition({
      name: "SectionDocumentUnion",
      types: sections.map((section) => _graphqlhelpers.friendlyName.call(void 0, section.slug, {suffix: "Document"}))
    }),
    ...mutationDefinitions(mutationsArray),
    queryDefinition(sectionMap)
  ];
  await sequential(sections.filter((section) => section.type === "directory"), async (section) => {
    buildSectionDefinitions(section, accumulator);
    await sequential(section.templates, async (templateSlug) => {
      const args = {
        cache: cache3,
        template: await cache3.datasource.getTemplate(templateSlug),
        accumulator,
        includeBody: true
      };
      await template.build.data(args);
      await template.build.values(args);
      await template.build.form(args);
      await template.build.input(args);
    });
  });
  const schema = {
    kind: "Document",
    definitions: _lodash2.default.uniqBy(accumulator, (field) => field.name.value)
  };
  return {schema, sectionMap};
};
const interfaceDefinitions = [
  gql.InterfaceTypeDefinition({
    name: "Node",
    fields: [
      gql.FieldDefinition({name: "id", type: gql.TYPES.ID, required: true})
    ]
  }),
  gql.InterfaceTypeDefinition({
    name: "Document",
    fields: [
      gql.FieldDefinition({name: "sys", type: gql.TYPES.SystemInfo}),
      gql.FieldDefinition({name: "id", type: gql.TYPES.ID, required: true})
    ]
  }),
  gql.InterfaceTypeDefinition({
    name: "FormField",
    fields: [
      gql.FieldDefinition({name: "label", type: gql.TYPES.String}),
      gql.FieldDefinition({name: "name", type: gql.TYPES.String}),
      gql.FieldDefinition({name: "component", type: gql.TYPES.String})
    ]
  })
];
const scalarDefinitions = [
  gql.ScalarTypeDefinition({
    name: "Reference",
    description: "References another document, used as a foreign key"
  }),
  gql.ScalarTypeDefinition({name: "JSON"}),
  gql.ScalarTypeDefinition({name: "JSONObject"})
];
const systemInfoDefinition = gql.ObjectTypeDefinition({
  name: "SystemInfo",
  fields: [
    gql.FieldDefinition({name: "filename", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "basename", type: gql.TYPES.String}),
    gql.FieldDefinition({
      name: "breadcrumbs",
      type: gql.TYPES.String,
      list: true,
      args: [
        gql.InputValueDefinition({
          name: "excludeExtension",
          type: gql.TYPES.Boolean
        })
      ]
    }),
    gql.FieldDefinition({name: "path", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "relativePath", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "extension", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "template", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "collection", type: gql.TYPES.Section})
  ]
});
const sectionDefinition = gql.ObjectTypeDefinition({
  name: "Section",
  fields: [
    gql.FieldDefinition({name: "type", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "path", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "label", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "create", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "match", type: gql.TYPES.String}),
    gql.FieldDefinition({name: "new_doc_ext", type: gql.TYPES.String}),
    gql.FieldDefinition({
      name: "templates",
      type: gql.TYPES.String,
      list: true
    }),
    gql.FieldDefinition({name: "slug", type: gql.TYPES.String}),
    gql.FieldDefinition({
      name: "documents",
      type: gql.TYPES.Document,
      list: true
    })
  ]
});
const buildSectionMap = (section, mutationsArray, sectionMap) => {
  const returnType = _graphqlhelpers.friendlyName.call(void 0, section.slug, {suffix: "Document"});
  mutationsArray.push({
    section,
    mutationName: `update${_graphqlhelpers.friendlyName.call(void 0, section.slug)}Document`,
    returnType
  });
  sectionMap[`update${_graphqlhelpers.friendlyName.call(void 0, section.slug)}Document`] = {
    section,
    plural: false,
    mutation: true,
    queryName: `update${_graphqlhelpers.friendlyName.call(void 0, section.slug)}Document`,
    returnType
  };
  sectionMap[`get${_graphqlhelpers.friendlyName.call(void 0, section.slug)}Document`] = {
    section,
    plural: false,
    queryName: `get${_graphqlhelpers.friendlyName.call(void 0, section.slug)}Document`,
    returnType
  };
  sectionMap[`get${_graphqlhelpers.friendlyName.call(void 0, section.slug)}List`] = {
    section,
    plural: true,
    queryName: `get${_graphqlhelpers.friendlyName.call(void 0, section.slug)}List`,
    returnType
  };
};
const mutationDefinitions = (mutationsArray) => {
  return [
    gql.InputObjectTypeDefinition({
      name: "SectionParams",
      fields: mutationsArray.map((ma) => {
        return gql.InputValueDefinition({
          name: ma.section.slug,
          type: _graphqlhelpers.friendlyName.call(void 0, ma.section.slug, {suffix: "Input"})
        });
      })
    }),
    gql.ObjectTypeDefinition({
      name: "Mutation",
      fields: [
        gql.FieldDefinition({
          name: "addPendingDocument",
          type: gql.TYPES.Document,
          args: [
            gql.InputValueDefinition({
              name: "relativePath",
              type: gql.TYPES.String
            }),
            gql.InputValueDefinition({
              name: "collection",
              type: gql.TYPES.String
            }),
            gql.InputValueDefinition({
              name: "template",
              type: gql.TYPES.String
            })
          ]
        }),
        gql.FieldDefinition({
          name: "updateDocument",
          type: gql.TYPES.SectionDocumentUnion,
          args: [
            gql.InputValueDefinition({
              name: "relativePath",
              type: gql.TYPES.String
            }),
            gql.InputValueDefinition({
              name: "params",
              type: gql.TYPES.SectionParams
            })
          ]
        }),
        ...mutationsArray.map((mutation) => {
          return gql.FieldDefinition({
            name: mutation.mutationName,
            type: mutation.returnType,
            args: [
              gql.InputValueDefinition({
                name: "relativePath",
                type: gql.TYPES.String
              }),
              gql.InputValueDefinition({
                name: "params",
                type: _graphqlhelpers.friendlyName.call(void 0, mutation.section.slug, {suffix: "Input"})
              })
            ]
          });
        })
      ]
    })
  ];
};
const queryDefinition = (sectionMap) => {
  return gql.ObjectTypeDefinition({
    name: "Query",
    fields: [
      gql.FieldDefinition({
        name: "node",
        type: gql.TYPES.Node,
        args: [
          gql.InputValueDefinition({
            name: "id",
            type: gql.TYPES.ID,
            required: true
          })
        ]
      }),
      gql.FieldDefinition({
        name: "getDocument",
        type: gql.TYPES.SectionDocumentUnion,
        args: [
          gql.InputValueDefinition({
            name: "collection",
            type: gql.TYPES.String
          }),
          gql.InputValueDefinition({
            name: "relativePath",
            type: gql.TYPES.String
          })
        ]
      }),
      gql.FieldDefinition({
        name: "getCollections",
        type: gql.TYPES.Section,
        list: true
      }),
      gql.FieldDefinition({
        name: "getCollection",
        type: gql.TYPES.Section,
        args: [
          gql.InputValueDefinition({
            name: "collection",
            type: gql.TYPES.String
          })
        ]
      }),
      ...Object.values(sectionMap).filter((section) => !section.mutation).map((section) => {
        return section.plural ? gql.FieldDefinition({
          name: section.queryName,
          type: section.returnType,
          list: true,
          args: []
        }) : gql.FieldDefinition({
          name: section.queryName,
          type: section.returnType,
          args: [
            gql.InputValueDefinition({
              name: "relativePath",
              type: gql.TYPES.String
            })
          ]
        });
      })
    ]
  });
};
const buildSectionDefinitions = (section, accumulator) => {
  const name = _graphqlhelpers.friendlyName.call(void 0, section.slug);
  accumulator.push(gql.UnionTypeDefinition({
    name: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Data"}),
    types: section.templates.map((template2) => _graphqlhelpers.templateTypeName.call(void 0, template2, "Data", true))
  }));
  accumulator.push(gql.InputObjectTypeDefinition({
    name: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Input"}),
    fields: section.templates.map((template2) => gql.InputValueDefinition({
      name: _graphqlhelpers.friendlyName.call(void 0, template2, {lowerCase: true}),
      type: _graphqlhelpers.templateTypeName.call(void 0, template2, "Input", true)
    }))
  }));
  accumulator.push(gql.UnionTypeDefinition({
    name: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Values"}),
    types: section.templates.map((template2) => _graphqlhelpers.templateTypeName.call(void 0, template2, "Values", true))
  }));
  accumulator.push(gql.UnionTypeDefinition({
    name: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Form"}),
    types: section.templates.map((template2) => _graphqlhelpers.templateTypeName.call(void 0, template2, "Form", true))
  }));
  accumulator.push(gql.ObjectTypeDefinition({
    name: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Document"}),
    interfaces: [
      gql.NamedType({name: "Node"}),
      gql.NamedType({name: "Document"})
    ],
    fields: [
      gql.FieldDefinition({name: "id", type: gql.TYPES.ID, required: true}),
      gql.FieldDefinition({name: "sys", type: gql.TYPES.SystemInfo}),
      gql.FieldDefinition({
        name: "data",
        type: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Data"})
      }),
      gql.FieldDefinition({
        name: "values",
        type: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Values"})
      }),
      gql.FieldDefinition({
        name: "form",
        type: _graphqlhelpers.friendlyName.call(void 0, name, {suffix: "Form"})
      })
    ]
  }));
};

// src/cache/index.ts
const cacheInit = (datasource) => {
  const cache3 = {
    gql: {
      object: (name, def) => {
        return __assign({
          kind: "ObjectTypeDefinition",
          name: cache3.gql.name(name)
        }, def);
      },
      union: (name, def) => {
        return {
          kind: "UnionTypeDefinition",
          name: {
            kind: "Name",
            value: "DocumentUnion"
          }
        };
      },
      name: (name) => ({kind: "Name", value: name}),
      string: (name) => {
        return {
          kind: "FieldDefinition",
          name: {
            kind: "Name",
            value: name
          },
          arguments: [],
          type: {
            kind: "NamedType",
            name: {
              kind: "Name",
              value: "String"
            }
          }
        };
      }
    },
    datasource
  };
  return cache3;
};

// src/resolver/index.ts

var _graphql = require('graphql');
var _path = require('path'); var _path2 = _interopRequireDefault(_path);

const graphqlInit = async (a) => {
  const {sectionMap} = a, rest2 = __rest(a, ["sectionMap"]);
  return await _graphql.graphql.call(void 0, __assign(__assign({}, rest2), {
    fieldResolver: async (source, args, context, info) => {
      return schemaResolver(source, args, context, info, sectionMap);
    },
    rootValue: {_resolver_kind: null}
  }));
};
const schemaResolver = async (source, args, context, info, sectionMap) => {
  const value = source[info.fieldName];
  switch (info.fieldName) {
    case "node":
      return resolveNode(args, context);
    case "documents":
      return resolveDocuments(value, args, context);
    case "getDocument":
      return resolveDocument({args, context});
    case "breadcrumbs":
      return resolveBreadcrumbs(value, args, context);
    case "getCollection":
      return resolveCollection(args, context);
    case "getCollections":
      return resolveCollections(context);
    case "addPendingDocument":
      await addPendingDocument(args, context);
      return resolveDocument({args, context});
    case "updateDocument":
      assertShape(args, (yup5) => yup5.object({
        relativePath: yup5.string().required(),
        params: yup5.object().required()
      }));
      const sectionSlug = Object.keys(args.params)[0];
      const params = Object.values(args.params)[0];
      const section = await context.datasource.getCollection(sectionSlug);
      const key = Object.keys(params)[0];
      const values = Object.values(params)[0];
      const templates5 = await context.datasource.getTemplatesForCollection(section.slug);
      const template2 = templates5.find((template3) => template3.name === key);
      if (!template2) {
        throw new Error(`Unabled to find template ${key} for section ${section.slug}`);
      }
      const realParams = await resolve.input({
        data: __assign(__assign({}, values), {
          _template: template2.name
        }),
        template: template2,
        datasource: context.datasource,
        includeBody: true
      });
      const relativePath = args.relativePath;
      const payload = {
        relativePath,
        collection: section.slug,
        params: realParams
      };
      assertShape(payload, (yup5) => {
        return yup5.object({
          relativePath: yup5.string().required(),
          collection: yup5.string().required(),
          params: yup5.object({
            _body: yup5.string()
          })
        });
      });
      await context.datasource.updateDocument(payload);
      return resolveDocument({
        args: {
          relativePath,
          collection: section.slug
        },
        context
      });
    default:
      break;
  }
  const sectionItem = sectionMap[info.fieldName];
  if (sectionItem) {
    if (sectionItem.plural) {
      const documents = await context.datasource.getDocumentsForCollection(sectionItem.section.slug);
      return sequential(documents, async (documentPath) => resolveDocument({
        args: {
          fullPath: documentPath,
          collection: sectionItem.section.slug
        },
        context
      }));
    } else if (sectionItem.mutation) {
      assertShape(args, (yup5) => yup5.object({
        relativePath: yup5.string().required(),
        params: yup5.object().required()
      }));
      const key = Object.keys(args.params)[0];
      const values = Object.values(args.params)[0];
      const templates5 = await context.datasource.getTemplatesForCollection(sectionItem.section.slug);
      const template2 = templates5.find((template3) => template3.name === key);
      if (!template2) {
        throw new Error(`Unabled to find template ${key} for section ${sectionItem.section.slug}`);
      }
      const params = await resolve.input({
        template: template2,
        data: __assign(__assign({}, values), {
          _template: template2.name
        }),
        datasource: context.datasource,
        includeBody: true
      });
      const payload = {
        relativePath: args.relativePath,
        collection: sectionItem.section.slug,
        params
      };
      assertShape(payload, (yup5) => {
        return yup5.object({
          relativePath: yup5.string().required(),
          collection: yup5.string().required(),
          params: yup5.object({
            _body: yup5.string()
          })
        });
      });
      await context.datasource.updateDocument(payload);
      return resolveDocument({
        args: {
          relativePath: args.relativePath,
          collection: sectionItem.section.slug
        },
        context
      });
    } else {
      return resolveDocument({
        args: {
          relativePath: args.relativePath,
          collection: sectionItem.section.slug
        },
        context
      });
    }
  }
  if (!value) {
    return null;
  }
  if (isReferenceField(value)) {
    switch (value._resolver_kind) {
      case "_nested_source":
        const documentArgs = {
          args: value._args,
          context
        };
        return resolveDocument(documentArgs);
      case "_nested_sources":
        return sequential(value._args.fullPaths, async (p4) => {
          return resolveDocument({
            args: __assign({fullPath: p4, collection: value._args.collection}, args),
            context
          });
        });
    }
  } else {
    return value;
  }
};
const resolveDocument = async ({
  args,
  context
}) => {
  var _a;
  const {datasource} = context;
  assertShape(args, (yup5) => yup5.object({
    relativePath: yup5.string(),
    fullPath: yup5.string(),
    collection: yup5.string().required()
  }));
  const sectionData = await datasource.getSettingsForCollection(args.collection);
  const relativePath = args.fullPath ? args.fullPath.replace(sectionData.path, "").replace(/^[^_a-z\d]*|[^_a-z\d]*$/gi, "") : ((_a = args.relativePath) == null ? void 0 : _a.startsWith(sectionData.path)) ? args.relativePath.replace(sectionData.path, "") : args.relativePath;
  if (!relativePath) {
    throw new Error(`Expected either relativePath or fullPath arguments`);
  }
  const realArgs = {relativePath, collection: args.collection};
  const {data, content} = await datasource.getData(realArgs);
  assertShape(data, (yup5) => yup5.object({
    _template: yup5.string().required()
  }));
  const {_template} = data, rest2 = __rest(data, ["_template"]);
  const template2 = await datasource.getTemplate(_template);
  const {basename, filename, extension} = await datasource.getDocumentMeta(realArgs);
  return {
    __typename: _graphqlhelpers.friendlyName.call(void 0, sectionData.slug, {suffix: "Document"}),
    id: _path2.default.join(sectionData.path, realArgs.relativePath),
    sys: {
      path: _path2.default.join(sectionData.path, realArgs.relativePath),
      relativePath,
      collection: sectionData,
      template: template2.name,
      breadcrumbs: relativePath.split("/").filter(Boolean),
      basename,
      filename,
      extension
    },
    form: await resolve.form({datasource, template: template2, includeBody: true}),
    data: await resolve.data({
      datasource,
      template: template2,
      data: rest2,
      content
    }),
    values: await resolve.values({
      datasource,
      template: template2,
      data: rest2,
      content: content || ""
    })
  };
};
const resolveNode = async (args, context) => {
  if (typeof args.id !== "string") {
    throw new Error("Expected argument ID for node query");
  }
  const section = await context.datasource.getCollectionByPath(args.id);
  return await resolveDocument({
    args: {fullPath: args.id, collection: section.slug},
    context
  });
};
const resolveDocuments = async (value, args, context) => {
  assertShape(value, (yup5) => yup5.object({_section: yup5.string().required()}));
  assertShape(args, (yup5) => yup5.object({collection: yup5.string()}));
  let sections = await context.datasource.getCollectionsSettings();
  if (args.collection) {
    sections = sections.filter((section) => section.slug === args.collection);
  }
  if (value && value._section) {
    sections = sections.filter((section) => section.slug === value._section);
  }
  const sectionDocs = _lodash2.default.flatten(await sequential(sections, async (s) => {
    const paths = await context.datasource.getDocumentsForCollection(s.slug);
    return await sequential(paths, async (documentPath) => {
      const document = await resolveDocument({
        args: {fullPath: documentPath, collection: s.slug},
        context
      });
      return document;
    });
  }));
  return sectionDocs;
};
const resolveBreadcrumbs = async (value, args, context) => {
  if (args.excludeExtension) {
    if (!Array.isArray(value)) {
      throw new Error(`Expected breadcrumb value to be an array`);
    }
    return value.map((item, i) => {
      if (i === value.length - 1) {
        return item.replace(_path2.default.extname(item), "");
      }
      return item;
    });
  } else {
    return value;
  }
};
const resolveCollection = async (args, context) => {
  assertShape(args, (yup5) => yup5.object({collection: yup5.string().required()}));
  let section = await context.datasource.getSettingsForCollection(args.collection);
  return __assign(__assign({}, section), {
    documents: {
      _section: section.slug
    }
  });
};
const resolveCollections = async (context) => {
  let sections = await context.datasource.getCollectionsSettings();
  return sequential(sections, async (section) => {
    return resolveCollection({collection: section.slug}, context);
  });
};
const addPendingDocument = async (args, context) => {
  assertShape(args, (yup5) => yup5.object({
    relativePath: yup5.string(),
    collection: yup5.string(),
    template: yup5.string()
  }));
  await context.datasource.addDocument(args);
  return true;
};
function isReferenceField(item) {
  try {
    assertShape(item, (yup5) => yup5.object({_resolver: yup5.string().required()}));
    return true;
  } catch (e) {
    return false;
  }
}

// src/types.ts
const byTypeWorks = (type) => (section) => section.type === type;

// src/datasources/data-manager.ts


var _graymatter = require('gray-matter'); var _graymatter2 = _interopRequireDefault(_graymatter);


var _jsyaml = require('js-yaml');
var _dataloader = require('dataloader'); var _dataloader2 = _interopRequireDefault(_dataloader);
const tinaPath = ".tina/__generated__/config";
class DataManager {
  constructor(rootPath, options) {
    this.getDocumentsForCollection = async (sectionSlug) => {
      const section = await this.getCollection(sectionSlug);
      const fullPath = _path2.default.join(this.rootPath, section.path);
      const documents = await readDir(fullPath, this.dirLoader);
      return documents.map((relativePath) => _path2.default.join(section.path, relativePath));
    };
    this.getAllTemplates = async () => {
      const fullPath = _path2.default.join(this.rootPath, tinaPath, "front_matter/templates");
      const templates5 = await readDir(fullPath, this.dirLoader);
      return await sequential(templates5, async (templateSlug) => await this.getTemplate(templateSlug.replace(".yml", "")));
    };
    this.getTemplates = async (templateSlugs) => await sequential(templateSlugs, async (templateSlug) => await this.getTemplate(templateSlug));
    this.getSettingsData = async () => {
      const {data} = await readFile(_path2.default.join(this.rootPath, tinaPath, "settings.yml"), this.loader);
      return data;
    };
    this.getSettingsForCollection = async (section) => {
      const sectionsSettings = await this.getCollectionsSettings();
      if (!section) {
        throw new Error(`No directory sections found`);
      }
      const result = sectionsSettings.find(({slug}) => slug === section);
      if (!result) {
        throw new Error(`Expected to find section with slug ${section}`);
      }
      return result;
    };
    this.getCollectionsSettings = async () => {
      const data = await this.getSettingsData();
      const sections = data.sections.filter((section) => section.type === "directory").map((section) => {
        return __assign(__assign({}, section), {
          slug: section.name
        });
      });
      return sections;
    };
    this.getCollection = async (slug) => {
      const data = await this.getSettingsData();
      const sections = data.sections.filter((section2) => section2.type === "directory").map((section2) => {
        return __assign(__assign({}, section2), {
          slug: section2.name
        });
      });
      const section = sections.find((section2) => section2.slug === slug);
      if (!section) {
        throw new Error(`Unable to find section with slug ${slug}`);
      }
      return section;
    };
    this.getCollectionByPath = async (path6) => {
      const data = await this.getSettingsData();
      const sections = data.sections.filter((section2) => section2.type === "directory").map((section2) => {
        return __assign(__assign({}, section2), {
          slug: section2.name
        });
      });
      const section = sections.find((section2) => {
        return path6.startsWith(section2.path);
      });
      if (!section) {
        throw new Error(`Unable to find section for path ${path6}`);
      }
      return section;
    };
    this.getTemplatesForCollection = async (section) => {
      var _a;
      const data = await this.getSettingsData();
      const sections = data.sections.map((section2) => {
        return __assign(__assign({}, section2), {
          slug: section2.name
        });
      });
      const templates5 = section ? (_a = sections.filter(byTypeWorks("directory")).find((templateSection) => {
        return templateSection.slug === section;
      })) == null ? void 0 : _a.templates : _lodash2.default.flatten(sections.filter(byTypeWorks("directory")).map(({templates: templates6}) => templates6));
      if (!templates5) {
        throw new Error(`No templates found for section`);
      }
      return await sequential(templates5, async (templateBasename) => {
        return await this.getTemplate(templateBasename.replace(".yml", ""));
      });
    };
    this.getDocumentMeta = async (args) => {
      const fullPath = _path2.default.join(this.rootPath, args.relativePath);
      const basename = _path2.default.basename(fullPath);
      const extension = _path2.default.extname(fullPath);
      return {basename, filename: basename.replace(extension, ""), extension};
    };
    this.getData = async ({relativePath, collection}) => {
      const sectionData = await this.getSettingsForCollection(collection);
      if (!sectionData) {
        throw new Error(`No section found for ${collection}`);
      }
      const fullPath = _path2.default.join(this.rootPath, sectionData.path, relativePath);
      return readFile(fullPath, this.loader);
    };
    this.getTemplateForDocument = async (args) => {
      const sectionData = await this.getSettingsForCollection(args.collection);
      if (!sectionData) {
        throw new Error(`No section found for ${args.collection}`);
      }
      const fullPath = _path2.default.join(this.rootPath, tinaPath, "front_matter/templates");
      const templates5 = await readDir(fullPath, this.dirLoader);
      const template2 = (await sequential(templates5, async (template3) => {
        var _a;
        const data = await this.getTemplate(template3.replace(".yml", ""));
        if ((_a = data.pages) == null ? void 0 : _a.includes(_path2.default.join(sectionData.path, args.relativePath))) {
          return data;
        } else {
          return false;
        }
      })).filter(Boolean)[0];
      if (!template2) {
        throw new Error(`Unable to find template for document ${args.relativePath}`);
      }
      return template2;
    };
    this.getTemplate = async (slug, options = {namespace: true}) => {
      const fullPath = _path2.default.join(this.rootPath, tinaPath, "front_matter/templates");
      const templates5 = await readDir(fullPath, this.dirLoader);
      const template2 = templates5.find((templateBasename) => {
        return templateBasename === `${slug}.yml`;
      });
      if (!template2) {
        throw new Error(`No template found for slug ${slug}`);
      }
      const {data} = await readFile(_path2.default.join(fullPath, template2), this.loader);
      return namespaceFields(__assign({name: slug}, data));
    };
    this.getTemplateWithoutName = async (slug, options = {namespace: true}) => {
      const fullPath = _path2.default.join(this.rootPath, tinaPath, "front_matter/templates");
      const templates5 = await readDir(fullPath, this.dirLoader);
      const template2 = templates5.find((templateBasename) => {
        return templateBasename === `${slug}.yml`;
      });
      if (!template2) {
        throw new Error(`No template found for slug ${slug}`);
      }
      const {data} = await readFile(_path2.default.join(fullPath, template2), this.loader);
      return data;
    };
    this.addDocument = async ({relativePath, collection, template: template2}) => {
      const fullPath = _path2.default.join(this.rootPath, tinaPath, "front_matter/templates");
      const sectionData = await this.getSettingsForCollection(collection);
      if (!sectionData) {
        throw new Error(`No section found for ${collection}`);
      }
      const path6 = _path2.default.join(sectionData.path, relativePath);
      const fullFilePath = _path2.default.join(this.rootPath, path6);
      const fullTemplatePath = _path2.default.join(fullPath, `${template2}.yml`);
      this.loader.clear(fullFilePath);
      this.loader.clear(fullTemplatePath);
      const documentString = "---\n" + _jsyaml.dump.call(void 0, {_template: template2});
      await this.writeFile(fullFilePath, documentString);
    };
    this.updateDocument = async ({relativePath, collection, params}) => {
      const sectionData = await this.getSettingsForCollection(collection);
      if (!sectionData) {
        throw new Error(`No section found for ${collection}`);
      }
      const fullPath = _path2.default.join(this.rootPath, sectionData.path, relativePath);
      this.loader.clear(fullPath);
      const {_body} = params, data = __rest(params, ["_body"]);
      const string2 = _graymatter2.default.stringify(`
${_body || ""}`, data);
      await this.writeFile(fullPath, string2);
    };
    this.rootPath = rootPath;
    const readFileFunc = createReadFileFunc(options.readFile);
    const readDirFunc = createReadDirFunc(options.readDir);
    this.loader = new (0, _dataloader2.default)(readFileFunc);
    this.dirLoader = new (0, _dataloader2.default)(readDirFunc);
    this.writeFile = options.writeFile;
    _graymatter2.default.clearCache();
  }
}
const createReadFileFunc = (readFileFunc) => {
  return async function batchReadFileFunction(keys) {
    const results = {};
    await Promise.all(keys.map(async (key) => results[key] = await internalReadFile(key, readFileFunc)));
    return keys.map((key) => results[key] || new Error(`No result for ${key}`));
  };
};
const createReadDirFunc = (readDirFunc) => {
  return async function batchReadDirFunction(keys) {
    const results = {};
    await Promise.all(keys.map(async (key) => results[key] = await internalReadDir(key, readDirFunc)));
    return keys.map((key) => results[key] || new Error(`No result for ${key}`));
  };
};
const readFile = async (path6, loader) => {
  return await loader.load(path6);
};
const internalReadFile = async (path6, readFileFunc) => {
  const extension = _path2.default.extname(path6);
  switch (extension) {
    case ".yml":
      const ymlString = await readFileFunc(path6);
      return parseMatter(ymlString);
    case ".md":
      const markdownString = await readFileFunc(path6);
      return parseMatter(markdownString);
    default:
      throw new Error(`Unable to parse file, unknown extension ${extension} for path ${path6}`);
  }
};
const readDir = async (path6, loader) => {
  return await loader.load(path6);
};
const internalReadDir = async (path6, readDirFunc) => {
  return readDirFunc(path6);
};
const parseMatter = (data) => {
  const res = _graymatter2.default.call(void 0, data, {
    excerpt_separator: "<!-- excerpt -->"
  });
  res.content = res.content.replace(/^\n|\n$/g, "");
  return res;
};
function isWithFields(t) {
  return t.hasOwnProperty("fields");
}
const namespaceFields = (template2) => {
  return __assign(__assign({}, template2), {
    fields: template2.fields.map((f) => {
      if (isWithFields(f)) {
        return __assign({}, namespaceSubFields(f, template2.name));
      } else {
        return __assign(__assign({}, f), {
          __namespace: `${template2.name}`
        });
      }
    })
  });
};
const namespaceSubFields = (template2, parentNamespace) => {
  return __assign(__assign({}, template2), {
    fields: template2.fields.map((f) => {
      if (isWithFields(f)) {
        return __assign(__assign({}, namespaceSubFields(f, template2.name)), {
          __namespace: `${parentNamespace}_${template2.name}`
        });
      } else {
        return __assign({}, f);
      }
    }),
    __namespace: parentNamespace
  });
};
const createDatasource = (dataAdaptor) => {
  return new DataManager(dataAdaptor.rootPath, {
    readFile: dataAdaptor.readFile,
    readDir: dataAdaptor.readDir,
    writeFile: dataAdaptor.writeFile
  });
};

// src/datasources/github-manager.ts


var _rest = require('@octokit/rest');
class GithubManager {
  constructor({
    rootPath,
    accessToken,
    owner,
    repo,
    ref,
    cache: cache3
  }) {
    this.generateKey = (key) => {
      return `${this.repoConfig.owner}:${this.repoConfig.repo}:${this.repoConfig.ref}__${key}`;
    };
    this.readFile = async (path6) => {
      return this.cache.get(this.generateKey(path6), async () => {
        return this.appOctoKit.repos.getContent(__assign(__assign({}, this.repoConfig), {
          path: path6
        })).then((response) => {
          return Buffer.from(response.data.content, "base64").toString();
        });
      });
    };
    this.readDir = async (path6) => {
      return _lodash2.default.flatten(await this.cache.get(this.generateKey(path6), async () => this.appOctoKit.repos.getContent(__assign(__assign({}, this.repoConfig), {
        path: path6
      })).then(async (response) => {
        if (Array.isArray(response.data)) {
          return await Promise.all(await response.data.map(async (d) => {
            if (d.type === "dir") {
              const nestedItems = await this.readDir(d.path);
              return nestedItems.map((nestedItem) => {
                return _path2.default.join(d.name, nestedItem);
              });
            }
            return d.name;
          }));
        }
        throw new Error(`Expected to return an array from Github directory ${path6}`);
      })));
    };
    this.writeFile = async (path6, content) => {
      let fileSha = void 0;
      try {
        const fileContent = await this.appOctoKit.repos.getContent(__assign(__assign({}, this.repoConfig), {
          path: path6
        }));
        fileSha = fileContent.data.sha;
      } catch (e) {
        console.log("No file exists, creating new one");
      }
      await this.appOctoKit.repos.createOrUpdateFileContents(__assign(__assign({}, this.repoConfig), {
        branch: this.repoConfig.ref,
        path: path6,
        message: "Update from GraphQL client",
        content: new Buffer(content).toString("base64"),
        sha: fileSha
      }));
    };
    this.cache = cache3 || dummyCache;
    this.rootPath = rootPath;
    this.repoConfig = {
      owner,
      repo,
      ref
    };
    this.appOctoKit = new (0, _rest.Octokit)({
      auth: accessToken
    });
  }
}
const dummyCache = {
  get: (key, setter) => {
    return setter();
  }
};

// src/datasources/filesystem-manager.ts
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);


class FileSystemManager {
  constructor({rootPath}) {
    this.readFile = async (path6) => {
      return _fsextra2.default.readFileSync(path6).toString();
    };
    this.readDir = async (path6) => {
      const result = _fsextra2.default.readdirSync(path6);
      return _lodash2.default.flatten(await Promise.all(result.map(async (item) => {
        const fullPath = _path2.default.join(path6, item);
        if (_fsextra2.default.lstatSync(fullPath).isDirectory()) {
          const nestedItems = await this.readDir(fullPath);
          return nestedItems.map((nestedItem) => {
            return _path2.default.join(item, nestedItem);
          });
        }
        return item;
      })));
    };
    this.writeFile = async (path6, content) => {
      return _fsextra2.default.outputFile(path6, content);
    };
    this.rootPath = rootPath;
  }
}

// src/lru.ts
var _lrucache = require('lru-cache'); var _lrucache2 = _interopRequireDefault(_lrucache);
const cache = new (0, _lrucache2.default)({
  max: 1e3,
  length: function(v, key) {
    return v.length;
  }
});
const clearCache = ({
  owner,
  repo,
  ref,
  path: path6
}) => {
  const repoPrefix = `${owner}:${repo}:${ref}__`;
  if (path6) {
    const key = `${repoPrefix}${path6}`;
    console.log("[LRU cache]: clearing key ", key);
    cache.del(key);
  } else {
    console.log("[LRU cache]: clearing all keys for repo ", repoPrefix);
    cache.forEach((value, key, cache3) => {
      if (key.startsWith(repoPrefix)) {
        cache3.del(key);
      }
    });
  }
};
const simpleCache = {
  get: async (keyName, setter) => {
    const value = cache.get(keyName);
    if (value) {
      console.log("getting from cache", keyName);
      return value;
    } else {
      const valueToCache = await setter();
      const isSet = cache.set(keyName, valueToCache);
      console.log("item not in cache, setting", keyName, isSet);
      return valueToCache;
    }
  }
};

// src/index.ts

const gql17 = async ({
  projectRoot,
  query,
  variables
}) => {
  const datasource = createDatasource(new FileSystemManager({rootPath: projectRoot}));
  const cache3 = cacheInit(datasource);
  try {
    const {schema, sectionMap} = await schemaBuilder({cache: cache3});
    const result = await graphqlInit({
      schema: _graphql.buildASTSchema.call(void 0, schema),
      source: query,
      contextValue: {datasource},
      variableValues: variables,
      sectionMap
    });
    return result;
  } catch (e) {
    console.log(e);
    return {error: e.message};
  }
};
const buildSchema = async (projectRoot) => {
  const datasource = createDatasource(new FileSystemManager({rootPath: projectRoot}));
  const cache3 = cacheInit(datasource);
  const {schema} = await schemaBuilder({cache: cache3});
  return _graphql.buildASTSchema.call(void 0, schema);
};
const githubRoute = async ({
  accessToken,
  owner,
  repo,
  query,
  variables,
  rootPath,
  branch
}) => {
  const gh = new GithubManager({
    rootPath: rootPath || "",
    accessToken,
    owner,
    repo,
    ref: branch,
    cache: simpleCache
  });
  const datasource = createDatasource(gh);
  const cache3 = cacheInit(datasource);
  const {schema, sectionMap} = await schemaBuilder({cache: cache3});
  const result = await graphqlInit({
    schema: _graphql.buildASTSchema.call(void 0, schema),
    source: query,
    contextValue: {datasource},
    variableValues: variables,
    sectionMap
  });
  if (result.errors) {
    console.error(result.errors);
  }
  return result;
};





exports.buildSchema = buildSchema; exports.clearCache = clearCache; exports.githubRoute = githubRoute; exports.gql = gql17;
