"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// src/cmds/start-server/server.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _cors = require('cors'); var _cors2 = _interopRequireDefault(_cors);
var _http = require('http'); var _http2 = _interopRequireDefault(_http);
var _express = require('express'); var _express2 = _interopRequireDefault(_express);
var _bodyparser = require('body-parser'); var _bodyparser2 = _interopRequireDefault(_bodyparser);
var require_server = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    default: () => server_default
  });
  var gqlServer = async () => {
    const gqlPackage = require("@forestryio/gql");
    const app = _express2.default.call(void 0, );
    const server = _http2.default.createServer(app);
    app.use(_cors2.default.call(void 0, ));
    app.use(_bodyparser2.default.json());
    let projectRoot = _path2.default.join(process.cwd());
    app.post("/graphql", async (req, res) => {
      const {query, variables} = req.body;
      const result = await gqlPackage.gql({projectRoot, query, variables});
      return res.json(result);
    });
    return server;
  };
  var server_default = gqlServer;
});

// src/index.ts


var _commander = require('commander');

// package.json
var version = "0.2.41";

// src/utils/theme.ts
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);
var successText = _chalk2.default.bold.green;
var dangerText = _chalk2.default.bold.red;
var neutralText = _chalk2.default.bold.cyan;
var labelText = _chalk2.default.bold;
var cmdText = _chalk2.default.inverse;
var logText = _chalk2.default.italic.gray;
var CONFIRMATION_TEXT = _chalk2.default.dim("enter to confirm");

// src/middleware.ts
var chain = async (cmds, options) => {
  let ctx = {};
  const next = async (middlewareIndex) => {
    if (middlewareIndex >= cmds.length) {
      process.exit(0);
    }
    try {
      await cmds[middlewareIndex](ctx, () => next(middlewareIndex + 1), options || {});
    } catch (err) {
      console.error(`  ${dangerText(err)}`);
      process.exit(1);
    }
  };
  if (cmds.length > 0) {
    await next(0);
  }
};

// src/cmds/query-gen/attachSchema.ts
var _gql = require('@forestryio/gql');
async function attachSchema(ctx, next, options) {
  const rootPath = process.cwd();
  const schema = await _gql.buildSchema.call(void 0, rootPath);
  ctx.schema = schema;
  next();
}

// src/codegen/index.ts
var _graphql = require('graphql');
var _core = require('@graphql-codegen/core');
var _typescript = require('@graphql-codegen/typescript');
var _typescriptoperations = require('@graphql-codegen/typescript-operations');
var generateTypes = async (schema) => {
  try {
    const res = await _core.codegen.call(void 0, {
      filename: process.cwd() + "/.forestry/autoschema.gql",
      schema: _graphql.parse.call(void 0, _graphql.printSchema.call(void 0, schema)),
      documents: [],
      config: {},
      plugins: [{typescript: {}}, {typescriptOperations: {}}],
      pluginMap: {
        typescript: {
          plugin: _typescript.plugin
        },
        typescriptOperations: {
          plugin: _typescriptoperations.plugin
        }
      }
    });
    return res;
  } catch (e) {
    console.error(e);
  }
};

// src/cmds/query-gen/genTypes.ts

var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
async function genTypes({schema}, next, options) {
  const typescriptTypes = await generateTypes(schema);
  const typesPath = process.cwd() + "/.tina/__generated__/types.ts";
  await _fsextra2.default.outputFile(typesPath, `// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
${typescriptTypes}
`);
  console.log(`Typescript types => ${successText(typesPath)}`);
  const schemaString = await _graphql.printSchema.call(void 0, schema);
  const schemaPath = process.cwd() + "/.tina/__generated__/schema.gql";
  await _fsextra2.default.outputFile(schemaPath, `# DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
${schemaString}
  `);
  console.log(`GraphQL types ====> ${successText(schemaPath)}`);
  next();
}

// src/cmds/start-server/index.ts
var _child_process = require('child_process'); var _child_process2 = _interopRequireDefault(_child_process);



// src/cmds/compile/index.ts
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);




var _typescript3 = require('typescript');


var _jsyaml = require('js-yaml');
var _yup = require('yup'); var yup = _interopRequireWildcard(_yup);
var tinaPath = _path2.default.join(process.cwd(), ".tina");
var tinaTempPath = _path2.default.join(process.cwd(), ".tina/__generated__/temp");
var tinaConfigPath = _path2.default.join(process.cwd(), ".tina/__generated__/config");
var transformField = async (tinaField, schema) => {
  const field = tinaField;
  if (field.type === "group") {
    return __assign(__assign({}, field), {
      type: "field_group",
      fields: await Promise.all(field.fields.map((field2) => transformField(field2, schema)))
    });
  }
  if (field.type === "toggle") {
    return __assign(__assign({}, field), {
      type: "boolean"
    });
  }
  if (field.type === "group-list") {
    return __assign(__assign({}, field), {
      type: "field_group_list",
      fields: await Promise.all(field.fields.map((field2) => transformField(field2, schema)))
    });
  }
  if (field.type === "tags") {
    return __assign(__assign({}, field), {
      type: "tag_list"
    });
  }
  if (field.type === "reference") {
    yup.object({
      collection: yup.string().oneOf(schema.collections.map((collection) => collection.name))
    }).validate(field);
    return {
      name: field.name,
      label: field.label,
      type: "select",
      config: {
        source: {
          type: "pages",
          section: field.collection
        }
      }
    };
  }
  if (field.type === "reference-list") {
    return {
      name: field.name,
      label: field.label,
      type: "list",
      config: {
        source: {
          type: "pages",
          section: field.collection
        }
      }
    };
  }
  if (field.type === "select") {
    return {
      name: field.name,
      label: field.label,
      type: "select",
      config: {
        source: {
          type: "simple"
        },
        options: field.options
      }
    };
  }
  return field;
};
var buildTemplate = async (definition, schema) => {
  const outputYmlPath = _path2.default.resolve(_path2.default.join(tinaTempPath.replace("temp", "config").replace(".js", ""), _path2.default.join("front_matter/templates", `${definition.name}.yml`)));
  const output = __assign({}, definition);
  output.fields = await Promise.all(definition.fields.map(async (field) => {
    if (field.type === "blocks") {
      return {
        name: field.name,
        label: field.label,
        type: "blocks",
        template_types: await Promise.all(field.templates.map(async (template, index) => {
          await buildTemplate(template, schema);
          return template.name;
        }))
      };
    }
    return transformField(field, schema);
  }));
  if (compiledTemplates.includes(output.name)) {
    return true;
  } else {
    compiledTemplates.push(output.name);
  }
  const templateString = "---\n" + _jsyaml.dump.call(void 0, output);
  await _fsextra2.default.outputFile(outputYmlPath, templateString);
  return true;
};
var types = [
  "text",
  "datetime",
  "number",
  "textarea",
  "tags",
  "image",
  "toggle",
  "select",
  "list",
  "group",
  "group-list",
  "blocks",
  "reference",
  "reference-list"
];
var compiledTemplates = [];
var compile = async () => {
  await _fsextra2.default.remove(tinaTempPath);
  await _fsextra2.default.remove(tinaConfigPath);
  await transpile2(tinaPath, tinaTempPath);
  Object.keys(require.cache).map((key) => {
    if (key.startsWith(tinaTempPath)) {
      delete require.cache[require.resolve(key)];
    }
  });
  const schemaFunc = require(_path2.default.join(tinaTempPath, "schema.js"));
  const schemaObject = schemaFunc.default.config;
  await compileInner(schemaObject);
  compiledTemplates = [];
};
var regexMessageFunc = (message) => `Field "${message.path}" with value "${message.value}" must match ${message.regex}. For example - "my-title" is invalid, use "myTitle" or "my_title instead`;
var compileInner = async (schemaObject) => {
  const sectionOutput = {
    sections: schemaObject.collections.map((collection) => {
      return __assign(__assign({}, collection), {
        type: "directory",
        create: "documents",
        match: "**/*.md",
        new_doc_ext: "md",
        templates: collection.templates.map((template) => template.name)
      });
    })
  };
  const schemaString = "---\n" + _jsyaml.dump.call(void 0, sectionOutput);
  await _fsextra2.default.outputFile(_path2.default.join(tinaTempPath.replace("temp", "config"), "settings.yml"), schemaString);
  await Promise.all(schemaObject.collections.map(async (collection) => await Promise.all(collection.templates.map(async (definition) => {
    return buildTemplate(definition, schemaObject);
  }))));
  console.log(`Tina config ======> ${successText(tinaConfigPath)}`);
  await _fsextra2.default.remove(tinaTempPath);
};
var transpile2 = async (projectDir, tempDir) => {
  return Promise.all(_fastglob2.default.sync(_path2.default.join(projectDir, "/**/*.ts"), {
    ignore: [_path2.default.join(projectDir, "__generated__/**/*.ts")]
  }).map(async function(file) {
    const fullPath = _path2.default.resolve(file);
    const contents = await _fsextra2.default.readFileSync(fullPath).toString();
    const newContent = _typescript3.transpile.call(void 0, contents);
    await _fsextra2.default.outputFile(file.replace(projectDir, tempDir).replace(".ts", ".js"), newContent);
    return true;
  }));
};
var ValidationError = class extends Error {
  constructor(validationMessage, ...params) {
    super(...params);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ValidationError);
    }
    this.name = "ValidationError";
    this.validationMessage = validationMessage;
  }
};
var defineSchema = (config) => {
  assertShape(config, (yup2) => {
    return yup2.object({
      collections: yup2.array().of(yup2.object({
        label: yup2.string().required(),
        path: yup2.string().required(),
        name: yup2.string().required().matches(/^[_a-zA-Z][_a-zA-Z0-9]*$/, {
          message: regexMessageFunc
        })
      })).min(1, (message) => `${message.path} must have at least 1 item`).required()
    });
  });
  yup.addMethod(yup.array, "oneOfSchemas", function(schemas) {
    return this.test("one-of-schemas", function(items, context) {
      if (typeof items === "undefined") {
        return;
      }
      try {
        return items.every((item) => {
          return schemas.some((schema, index) => {
            if (schema.isValidSync(item, {strict: true})) {
              return true;
            } else {
              if (item.type) {
                const isAType = yup.string().oneOf(types).required().isValidSync(item.type, {strict: true});
                if (!isAType) {
                  throw new ValidationError({
                    message: `at path ${context.path} \`type\` must be one of:
	${types.join(", ")}
but received \`${item.type}\``
                  });
                } else {
                  const schema2 = schemaMap[item.type];
                  let error = "";
                  if (!schema2) {
                  } else {
                    try {
                      schema2.validateSync(item);
                    } catch (e) {
                      error = e.errors.join("\n");
                      throw new ValidationError({
                        message: `Not all items in ${context.path} match one of the allowed schemas:
	${error}`
                      });
                    }
                  }
                }
              }
              return false;
            }
          });
        });
      } catch (e) {
        if (e instanceof ValidationError) {
          return context.createError(e.validationMessage);
        } else {
          throw e;
        }
      }
    });
  });
  const baseSchema = yup.object({
    label: yup.string().required(),
    name: yup.string().required().matches(/^[_a-zA-Z][_a-zA-Z0-9]*$/, {
      message: regexMessageFunc
    }),
    description: yup.string()
  });
  const TextSchema = baseSchema.label("text").shape({
    type: yup.string().matches(/^text$/).required()
  });
  const DateTimeSchema = baseSchema.label("datetime").shape({
    type: yup.string().matches(/^datetime$/).required(),
    dateFormat: yup.string(),
    timeFormat: yup.string()
  });
  const ToggleSchema = baseSchema.label("toggle").shape({
    type: yup.string().matches(/^toggle$/).required()
  });
  const ImageSchema = baseSchema.label("image").shape({
    type: yup.string().matches(/^image$/).required()
  });
  const NumberSchema = baseSchema.label("number").shape({
    type: yup.string().matches(/^number$/).required()
  });
  const TextAreaSchema = baseSchema.label("textarea").shape({
    type: yup.string().matches(/^textarea$/).required()
  });
  const TagsSchema = baseSchema.label("tags").shape({
    type: yup.string().matches(/^tags$/).required()
  });
  const SelectSchema = baseSchema.label("select").shape({
    type: yup.string().matches(/^select$/).required(),
    options: yup.array().min(1).of(yup.string()).required()
  });
  const ListSchema = baseSchema.label("list").shape({
    type: yup.string().matches(/^list$/).required()
  });
  const GroupSchema = baseSchema.label("group").shape({
    type: yup.string().matches(/^group$/).required(),
    fields: yup.lazy(() => yup.array().min(1, (message) => `${message.path} must have at least 1 item`).oneOfSchemas(FieldSchemas).required())
  });
  const GroupListSchema = baseSchema.label("group-list").shape({
    type: yup.string().matches(/^group-list$/).required(),
    fields: yup.lazy(() => yup.array().min(1, (message) => `${message.path} must have at least 1 item`).oneOfSchemas(FieldSchemas).required())
  });
  const ReferenceSchema = baseSchema.label("reference").shape({
    type: yup.string().matches(/^reference$/).required(),
    collection: yup.string().oneOf(config.collections.map((collection) => collection.name)).required()
  });
  const ReferenceListSchema = baseSchema.label("reference-list").shape({
    type: yup.string().matches(/^reference-list$/).required(),
    collection: yup.string().oneOf(config.collections.map((collection) => collection.name), (message) => `${message.path} must be one of the following values: ${message.values}, but instead received: ${message.value}`).required()
  });
  const BlocksSchema = baseSchema.label("blocks").shape({
    type: yup.string().matches(/^blocks$/).required(),
    templates: yup.lazy(() => yup.array().min(1, (message) => `${message.path} must have at least 1 item`).of(TemplateSchema).required("templates is a required field"))
  });
  let schemaMap = {
    text: TextSchema,
    datetime: DateTimeSchema,
    textarea: TextAreaSchema,
    select: SelectSchema,
    list: ListSchema,
    group: GroupSchema,
    "group-list": GroupListSchema,
    reference: ReferenceSchema,
    "reference-list": ReferenceListSchema,
    blocks: BlocksSchema
  };
  var FieldSchemas = [
    TextSchema,
    DateTimeSchema,
    TextAreaSchema,
    SelectSchema,
    ListSchema,
    NumberSchema,
    TagsSchema,
    ToggleSchema,
    BlocksSchema,
    GroupSchema,
    GroupListSchema,
    ReferenceSchema,
    ReferenceListSchema
  ];
  const TemplateSchema = yup.object({
    label: yup.string().required(),
    name: yup.string().required().matches(/^[_a-zA-Z][_a-zA-Z0-9]*$/, {
      message: regexMessageFunc
    }),
    fields: yup.array().min(1, (message) => `${message.path} must have at least 1 item`).oneOfSchemas(FieldSchemas).required()
  });
  assertShape(config, (yup2) => yup2.object({
    collections: yup2.array().min(1, (message) => `${message.path} must have at least 1 item`).of(yup2.object({
      label: yup2.string().required(),
      path: yup2.string().required(),
      name: yup2.string().required(),
      templates: yup2.array().min(1, (message) => `${message.path} must have at least 1 item`).of(TemplateSchema).required("templates is a required field")
    })).required("collections is a required field")
  }));
  return {_definitionType: "schema", config};
};
function assertShape(value, yupSchema) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    throw new Error(`There were some issues when compiling your schema:
${dangerText(e.errors.join("\n"))}`);
  }
}

// src/cmds/start-server/index.ts
var _chokidar = require('chokidar'); var _chokidar2 = _interopRequireDefault(_chokidar);
var gqlPackageFile = require.resolve("@forestryio/gql");
async function startServer(_ctx, _next, {port = 4001, command}) {
  const startSubprocess = () => {
    if (typeof command === "string") {
      const commands = command.split(" ");
      const ps = _child_process2.default.spawn(commands[0], [commands[1]], {
        stdio: "inherit"
      });
      ps.on("close", (code) => {
        console.log(`child process exited with code ${code}`);
        process.exit(code);
      });
    }
  };
  let projectRoot = _path2.default.join(process.cwd());
  let ready = false;
  if (!process.env.CI) {
    _chokidar2.default.watch(`${projectRoot}/**/*.ts`, {
      ignored: `${_path2.default.resolve(projectRoot)}/.tina/__generated__/**/*`
    }).on("ready", async () => {
      try {
        console.log("Generating Tina config");
        await compile();
        const schema = await _gql.buildSchema.call(void 0, process.cwd());
        await genTypes({schema}, () => {
        }, {});
        ready = true;
        startSubprocess();
      } catch (e) {
        console.log(dangerText(`${e.message}, exiting...`));
        console.log(e);
        process.exit(0);
      }
    }).on("all", async (event, path4) => {
      if (ready) {
        console.log("Tina change detected, regenerating config");
        try {
          await compile();
          const schema = await _gql.buildSchema.call(void 0, process.cwd());
          await genTypes({schema}, () => {
          }, {});
        } catch (e) {
          console.log(dangerText("Compilation failed with errors, server has not been restarted"));
          console.log(e.message);
        }
      }
    });
  }
  const state = {
    server: null,
    sockets: []
  };
  let isReady = false;
  const start = async () => {
    const s = require_server();
    state.server = await s.default();
    state.server.listen(port, () => {
      console.log(`Started Filesystem GraphQL server on port: ${port}`);
    });
    state.server.on("connection", (socket) => {
      state.sockets.push(socket);
    });
  };
  const restart = async () => {
    console.log("Detected change to gql package, restarting...");
    delete require.cache[gqlPackageFile];
    state.sockets.forEach((socket, index) => {
      if (socket.destroyed === false) {
        socket.destroy();
      }
    });
    state.sockets = [];
    state.server.close(() => {
      console.log("Server closed");
      start();
    });
  };
  if (!process.env.CI) {
    _chokidar2.default.watch(gqlPackageFile).on("ready", async () => {
      isReady = true;
      start();
    }).on("all", async () => {
      if (isReady) {
        restart();
      }
    });
  } else {
    console.log("Detected CI environment, omitting watch commands...");
    start();
    startSubprocess();
  }
}

// src/cmds/baseCmds.ts
var CMD_GEN_TYPES = "schema:types";
var CMD_START_SERVER = "server:start";
var CMD_COMPILE_MODELS = "schema:compile";
var startServerPortOption = {
  name: "--port <port>",
  description: "Specify a port to run the server on. (default 4001)"
};
var subCommand = {
  name: "-c, --command <command>",
  description: "The sub-command to run"
};
var baseCmds = [
  {
    command: CMD_START_SERVER,
    description: "Start Filesystem Graphql Server",
    options: [startServerPortOption, subCommand],
    action: (options) => chain([startServer], options)
  },
  {
    command: CMD_COMPILE_MODELS,
    description: "Compile schema into static files for the server",
    action: (options) => chain([compile], options)
  },
  {
    command: CMD_GEN_TYPES,
    description: "Generate a GraphQL query for your site's schema, (and optionally Typescript types)",
    action: (options) => chain([attachSchema, genTypes], options)
  }
];

// src/index.ts
var program = new (0, _commander.Command)();
var registerCommands = (commands, noHelp = false) => {
  commands.forEach((command, i) => {
    let newCmd = program.command(command.command, {noHelp}).description(command.description).action((...args) => {
      console.log("");
      command.action(...args);
    });
    if (command.alias) {
      newCmd = newCmd.alias(command.alias);
    }
    newCmd.on("--help", function() {
      if (command.examples) {
        console.log(`
Examples:
  ${command.examples}`);
      }
      if (command.subCommands) {
        console.log("\nCommands:");
        const optionTag = " [options]";
        command.subCommands.forEach((subcommand, i2) => {
          const commandStr = `${subcommand.command}${(subcommand.options || []).length ? optionTag : ""}`;
          const padLength = Math.max(...command.subCommands.map((sub) => sub.command.length)) + optionTag.length;
          console.log(`${commandStr.padEnd(padLength)} ${subcommand.description}`);
        });
      }
      console.log("");
    });
    (command.options || []).forEach((option) => {
      newCmd.option(option.name, option.description);
    });
    if (command.subCommands) {
      registerCommands(command.subCommands, true);
    }
  });
};
async function init(args) {
  program.version(version);
  const commands = [...baseCmds];
  registerCommands(commands);
  program.usage("command [options]");
  program.on("command:*", function() {
    console.error("Invalid command: %s\nSee --help for a list of available commands.", args.join(" "));
    process.exit(1);
  });
  program.on("--help", function() {
    console.log(logText(`
You can get help on any command with "-h" or "--help".
e.g: "forestry types:gen --help"
    `));
  });
  if (!process.argv.slice(2).length) {
    program.help();
  }
  program.parse(args);
}



exports.defineSchema = defineSchema; exports.init = init;
