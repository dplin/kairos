"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __hasOwnProperty = Object.prototype.hasOwnProperty;
var __getOwnPropertySymbols = Object.getOwnPropertySymbols;
var __propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProperty.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropertySymbols) {
    for (var prop of __getOwnPropertySymbols(source))
      if (exclude.indexOf(prop) < 0 && __propertyIsEnumerable.call(source, prop))
        target[prop] = source[prop];
  }
  return target;
};

// src/auth/popupWindow.ts
function popupWindow(url, title, window2, w, h) {
  const y = window2.top.outerHeight / 2 + window2.top.screenY - h / 2;
  const x = window2.top.outerWidth / 2 + window2.top.screenX - w / 2;
  return window2.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=" + w + ", height=" + h + ", top=" + y + ", left=" + x);
}
var popupWindow_default = popupWindow;

// src/auth/authenticate.ts
const TINA_LOGIN_EVENT = "tinaCloudLogin";
const AUTH_TOKEN_KEY = "tinacms-auth";
const BASE_TINA_URL = process.env.BASE_TINA_URL || `tina.io`;
const authenticate = (clientId, organizationId) => {
  return new Promise((resolve) => {
    let authTab;
    window.addEventListener("message", function(e) {
      if (e.data.source === TINA_LOGIN_EVENT) {
        if (authTab) {
          authTab.close();
        }
        resolve({
          id_token: e.data.id_token,
          access_token: e.data.access_token,
          refresh_token: e.data.refresh_token
        });
      }
    });
    authTab = popupWindow_default(`https://${organizationId}.${BASE_TINA_URL}/signin?clientId=${clientId}`, "_blank", window, 1e3, 700);
  });
};

// src/client/transform-payload.ts
var _graphqlhelpers = require('@forestryio/graphql-helpers');






var _graphql = require('graphql');
const transformPayload = ({
  mutation,
  values,
  schema,
  sys
}) => {
  try {
    const accum = {};
    const parsedMutation = _graphql.parse.call(void 0, mutation);
    const mutationName = parsedMutation.definitions.find((def) => def.kind === "OperationDefinition" && def.operation === "mutation").selectionSet.selections[0].name.value;
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new Error(`Expected to find mutation type in schema`);
    }
    const mutationNameType = mutationType.getFields()[mutationName];
    if (!mutationNameType) {
      throw new Error(`Expected to find mutation type ${mutationNameType}`);
    }
    const paramsArg = mutationNameType.args.find((arg) => arg.name === "params");
    const inputType = paramsArg.type;
    if (inputType instanceof _graphql.GraphQLInputObjectType) {
      if (inputType.name === "SectionParams") {
        const section = Object.values(inputType.getFields()).find((field) => {
          return field.name === sys.collection.slug;
        });
        if (section.type instanceof _graphql.GraphQLInputObjectType) {
          const template = Object.values(section.type.getFields()).find((field) => {
            const templateNameString = _graphqlhelpers.friendlyName.call(void 0, sys.template, {
              lowerCase: true
            });
            return field.name === templateNameString;
          });
          if (template) {
            const transformedInput = transformInputObject(values, accum, section.type);
            const payload = {
              [section.name]: transformedInput
            };
            return payload;
          } else {
            throw new Error(`Unable to find matching template for ${sys.template} in collection ${sys.collection.slug}`);
          }
        }
      }
      return transformInputObject(values, accum, inputType);
    } else {
      throw new Error(`Unable to transform payload, expected param arg to by an instance of GraphQLInputObjectType`);
    }
  } catch (e) {
    console.log("oh no", e);
  }
};
const transformInputObject = (values, accum, payloadType) => {
  const fields = payloadType.getFields();
  const template = values["_template"];
  if (!template) {
    return values;
  }
  const templateNameString = _graphqlhelpers.friendlyName.call(void 0, template, {
    lowerCase: true
  });
  const templateField = fields[templateNameString];
  if (!templateField) {
    return values;
  }
  const templateType = _graphql.getNamedType.call(void 0, templateField.type);
  if (templateType instanceof _graphql.GraphQLInputObjectType) {
    const fieldTypes = {};
    Object.values(templateType.getFields()).map((field) => {
      const fieldType = _graphql.getNamedType.call(void 0, field.type);
      const valueForField = values[field.name];
      if (_graphql.isScalarType.call(void 0, fieldType)) {
        fieldTypes[field.name] = valueForField;
      } else {
        if (field.type instanceof _graphql.GraphQLList) {
          fieldTypes[field.name] = (valueForField || []).map((val) => {
            if (fieldType instanceof _graphql.GraphQLInputObjectType) {
              return transformInputObject(val, {}, fieldType);
            } else {
              throw new Error(`Expected instance of GraphQLInputObjectType but got ${fieldType}`);
            }
          });
        } else {
          fieldTypes[field.name] = valueForField;
        }
      }
    });
    accum[templateNameString] = fieldTypes;
  }
  return accum;
};

// src/client/media-store.ts
class ForestryMediaStore {
  constructor(client) {
    this.client = client;
    this.accept = "*";
    this.client = client;
  }
  async persist(files) {
    const uploaded = [];
    return uploaded;
  }
  async previewSrc(src) {
    return src;
  }
  async list(options) {
    var _a, _b, _c;
    const directory = (_a = options == null ? void 0 : options.directory) != null ? _a : "";
    const offset = (_b = options == null ? void 0 : options.offset) != null ? _b : 0;
    const limit = (_c = options == null ? void 0 : options.limit) != null ? _c : 50;
    return {
      items: [],
      totalCount: 0,
      offset: 0,
      limit: 10,
      nextOffset: nextOffset(offset, limit, 3)
    };
  }
  async delete(media) {
  }
}
const nextOffset = (offset, limit, count) => {
  if (offset + limit < count)
    return offset + limit;
  return void 0;
};

// src/client/index.ts






var _graphqltag = require('graphql-tag'); var _graphqltag2 = _interopRequireDefault(_graphqltag);
const BASE_TINA_URL2 = process.env.BASE_TINA_URL || `tinajs.io`;
const IDENTITY_API_URL = process.env.IDENTITY_API_OVERRIDE || `https://identity.${BASE_TINA_URL2}`;
const CONTENT_API_URL = process.env.CONTENT_API_OVERRIDE || `https://content.${BASE_TINA_URL2}`;
class Client {
  constructor(_a) {
    this.addPendingContent = async (props) => {
      const mutation = `mutation addPendingDocumentMutation($relativePath: String!, $template: String!, $collection: String!) {
      addPendingDocument(relativePath: $relativePath, template: $template, collection: $collection) {
        sys {
          relativePath
          path
          breadcrumbs(excludeExtension: true)
          collection {
            slug
          }
        }
      }
    }`;
      const result = await this.request(mutation, {
        variables: props
      });
      return result;
    };
    this.getSchema = async () => {
      if (!this.schema) {
        const data = await this.request(_graphql.getIntrospectionQuery.call(void 0, ), {
          variables: {}
        });
        this.schema = _graphql.buildClientSchema.call(void 0, data);
      }
      return this.schema;
    };
    this.prepareVariables = async ({
      mutationString,
      relativePath,
      values,
      sys
    }) => {
      const schema = await this.getSchema();
      const params = transformPayload({
        mutation: mutationString,
        values,
        sys,
        schema
      });
      return {
        relativePath,
        params
      };
    };
    var {tokenStorage = "MEMORY"} = _a, options = __rest(_a, ["tokenStorage"]);
    const _this = this;
    this.contentApiUrl = options.customContentApiUrl || `${CONTENT_API_URL}/content/${options.organizationId}/${options.clientId}/github/${options.branch}`, this.clientId = options.clientId;
    this.organizationId = options.organizationId;
    switch (tokenStorage) {
      case "LOCAL_STORAGE":
        this.getToken = function() {
          const tokens = localStorage.getItem(AUTH_TOKEN_KEY) || null;
          if (tokens) {
            return JSON.parse(tokens);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = function(token) {
          localStorage.setItem(AUTH_TOKEN_KEY, JSON.stringify(token, null, 2));
        };
        break;
      case "MEMORY":
        this.getToken = function() {
          if (_this.token) {
            return JSON.parse(_this.token);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = function(token) {
          _this.token = JSON.stringify(token, null, 2);
        };
        break;
      case "CUSTOM":
        if (!options.getTokenFn) {
          throw new Error("When CUSTOM token storage is selected, a getTokenFn must be provided");
        }
        this.getToken = options.getTokenFn;
        break;
    }
  }
  async requestWithForm(query, {variables}) {
    const schema = await this.getSchema();
    const formifiedQuery = _graphqlhelpers.formify.call(void 0, query(_graphqltag2.default), schema);
    return this.request(_graphql.print.call(void 0, formifiedQuery), {variables});
  }
  async request(query, {variables}) {
    const res = await fetch(this.contentApiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + this.getToken().id_token
      },
      body: JSON.stringify({
        query: typeof query === "function" ? _graphql.print.call(void 0, query(_graphqltag2.default)) : query,
        variables
      })
    });
    const json = await res.json();
    if (json.errors) {
      throw new Error(`Unable to fetch, errors: 
	${json.errors.map((error) => error.message).join("\n")}`);
      return json;
    }
    return json.data;
  }
  async isAuthorized() {
    if (this.isLocalClient()) {
      return true;
    }
    return this.isAuthenticated();
  }
  isLocalClient() {
    return !this.clientId;
  }
  async isAuthenticated() {
    if (this.isLocalClient()) {
      return true;
    }
    return !!await this.getUser();
  }
  async authenticate() {
    const token = await authenticate(this.clientId, this.organizationId);
    this.setToken(token);
    return token;
  }
  async getUser() {
    const url = `${IDENTITY_API_URL}/realm/${this.organizationId}/${this.clientId}/currentUser`;
    try {
      const res = await fetch(url, {
        method: "GET",
        headers: new Headers({
          Authorization: "Bearer " + this.getToken().id_token,
          "Content-Type": "application/json"
        })
      });
      const val = await res.json();
      if (!res.status.toString().startsWith("2")) {
        console.error(val.error);
        return null;
      }
      return val;
    } catch (e) {
      console.error(e);
      return null;
    }
  }
}
const DEFAULT_LOCAL_TINA_GQL_SERVER_URL = "http://localhost:4001/graphql";
class LocalClient extends Client {
  constructor(props) {
    const clientProps = {
      organizationId: "",
      clientId: "",
      branch: "",
      customContentApiUrl: props && props.customContentApiUrl ? props.customContentApiUrl : DEFAULT_LOCAL_TINA_GQL_SERVER_URL
    };
    super(clientProps);
  }
}

// src/auth/AuthModal.tsx






var _tinacms = require('tinacms');
var _styles = require('@tinacms/styles');
var _react = require('react'); var _react2 = _interopRequireDefault(_react);
var _reactforms = require('@tinacms/react-forms');

var _styledcomponents = require('styled-components'); var _styledcomponents2 = _interopRequireDefault(_styledcomponents);
function ModalBuilder(modalProps) {
  return /* @__PURE__ */ _react2.default.createElement(_styles.StyleReset, null, /* @__PURE__ */ _react2.default.createElement(_tinacms.Modal, null, /* @__PURE__ */ _react2.default.createElement(_tinacms.ModalPopup, null, /* @__PURE__ */ _react2.default.createElement(_tinacms.ModalHeader, null, modalProps.title), /* @__PURE__ */ _react2.default.createElement(_tinacms.ModalBody, {
    padded: true
  }, /* @__PURE__ */ _react2.default.createElement("p", null, modalProps.message), modalProps.error && /* @__PURE__ */ _react2.default.createElement(ErrorLabel, null, modalProps.error)), /* @__PURE__ */ _react2.default.createElement(_tinacms.ModalActions, null, modalProps.actions.map((action) => /* @__PURE__ */ _react2.default.createElement(AsyncButton, __assign({}, action)))))));
}
const ErrorLabel = _styledcomponents2.default.p`
  color: var(--tina-color-error) !important;
`;
const AsyncButton = ({name, primary, action}) => {
  const [submitting, setSubmitting] = _react.useState.call(void 0, false);
  const onClick = _react.useCallback.call(void 0, async () => {
    setSubmitting(true);
    try {
      await action();
      setSubmitting(false);
    } catch (e) {
      setSubmitting(false);
      throw e;
    }
  }, [action, setSubmitting]);
  return /* @__PURE__ */ _react2.default.createElement(_styles.Button, {
    primary,
    onClick,
    busy: submitting,
    disabled: submitting
  }, submitting && /* @__PURE__ */ _react2.default.createElement(_reactforms.LoadingDots, null), !submitting && name);
};

// src/auth/useTinaAuthRedirect.tsx

const TINA_AUTH_CONFIG = "tina_auth_config";
const useTinaAuthRedirect = () => {
  _react.useEffect.call(void 0, () => {
    const urlParams = new URLSearchParams(window.location.search);
    const config = {
      code: urlParams.get("code") || "",
      scope: urlParams.get("scope") || "email",
      state: urlParams.get("state")
    };
    if (!config.code) {
      return;
    }
    localStorage[TINA_AUTH_CONFIG] = JSON.stringify(config);
  }, []);
};

// src/auth/TinaCloudProvider.tsx


function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const AuthWallInner = ({
  children,
  cms,
  loginScreen,
  getModalActions
}) => {
  const client = cms.api.tina;
  const [activeModal, setActiveModal] = _react.useState.call(void 0, null);
  const [showChildren, setShowChildren] = _react.useState.call(void 0, false);
  _react2.default.useEffect(() => {
    client.isAuthenticated().then((isAuthenticated) => {
      if (isAuthenticated) {
        setShowChildren(true);
        cms.enable();
      } else {
        sleep(500).then(() => {
          setActiveModal("authenticate");
        });
      }
    });
  }, []);
  const onAuthSuccess = async (token) => {
    if (await client.isAuthenticated()) {
      setShowChildren(true);
      setActiveModal(null);
    } else {
      throw new Error("No access to repo");
    }
  };
  const otherModalActions = getModalActions ? getModalActions({closeModal: () => {
    setActiveModal(null);
  }}) : [];
  return /* @__PURE__ */ _react2.default.createElement(_react2.default.Fragment, null, activeModal === "authenticate" && /* @__PURE__ */ _react2.default.createElement(ModalBuilder, {
    title: "Tina Cloud Authorization",
    message: "To save edits, Tina Cloud authorization is required. On save, changes will get commited using your account.",
    close,
    actions: [
      ...otherModalActions,
      {
        name: "Continue to Tina Cloud",
        action: async () => {
          const token = await client.authenticate();
          onAuthSuccess(token);
        },
        primary: true
      }
    ]
  }), showChildren ? children : loginScreen ? loginScreen : null);
};
const TinaCloudAuthWall = (props) => {
  useTinaAuthRedirect();
  return /* @__PURE__ */ _react2.default.createElement(_tinacms.TinaProvider, {
    cms: props.cms
  }, /* @__PURE__ */ _react2.default.createElement(AuthWallInner, __assign({}, props)));
};

// src/auth/index.tsx

// src/hooks/temporary-fix-mutators.ts
var _finalformarrays = require('final-form-arrays'); var _finalformarrays2 = _interopRequireDefault(_finalformarrays);
var _finalform = require('final-form');
const fixMutators = (args) => {
  const {form, context, callback} = args;
  const changeValue = (state, name, mutate) => {
    const before = _finalform.getIn.call(void 0, state.formState.values, name);
    const after = mutate(before);
    state.formState.values = _finalform.setIn.call(void 0, state.formState.values, name, after) || {};
  };
  const {move: moveCopy, remove: removeCopy, insert: insertCopy} = __assign({}, form.finalForm.mutators);
  form.finalForm.mutators.move = (name, from, to) => {
    const dataValue = _finalform.getIn.call(void 0, context.node.data, name);
    let state = {
      formState: {values: {fakeValue: dataValue}}
    };
    try {
      _finalformarrays2.default.move(["fakeValue", from, to], state, {changeValue});
    } catch (e) {
      callback({
        type: "ON_FIELD_CHANGE",
        values: {
          path: [context.queryFieldName, "data", ...name.split(".")],
          value: state.formState.values.fakeValue
        }
      });
    }
    return moveCopy(name, from, to);
  };
  form.finalForm.mutators.remove = (name, index) => {
    const dataValue = _finalform.getIn.call(void 0, context.node.data, name);
    let state = {
      formState: {values: {fakeValue: dataValue}}
    };
    try {
      _finalformarrays2.default.remove(["fakeValue", index], state, {changeValue});
    } catch (e) {
      callback({
        type: "ON_FIELD_CHANGE",
        values: {
          path: [context.queryFieldName, "data", ...name.split(".")],
          value: state.formState.values.fakeValue
        }
      });
    }
    return removeCopy(name, index);
  };
  form.finalForm.mutators.insert = (name, index, item) => {
    const dataValue = _finalform.getIn.call(void 0, context.node.data, name);
    let state = {
      formState: {values: {fakeValue: dataValue}}
    };
    try {
      let newItem = item;
      if (item._template) {
        newItem = {
          __typename: item._template.charAt(0).toUpperCase() + item._template.slice(1) + "_Data"
        };
      } else {
        if (item && Object.keys(item).length === 0 && item.constructor === Object) {
          item = null;
        }
      }
      _finalformarrays2.default.insert(["fakeValue", index, newItem], state, {
        changeValue
      });
    } catch (e) {
      callback({
        type: "ON_FIELD_CHANGE",
        values: {
          path: [context.queryFieldName, "data", ...name.split(".")],
          value: state.formState.values.fakeValue
        }
      });
    }
    return insertCopy(name, index, item);
  };
};

// src/hooks/form-service.ts





var _xstate = require('xstate');


const createFormMachine = (initialContext) => {
  const id = initialContext.queryFieldName + "_FormService";
  return _xstate.createMachine.call(void 0, {
    id,
    initial: "loading",
    states: {
      loading: {
        invoke: {
          id: id + "breakdownData",
          src: async (context, event) => {
            return _graphqlhelpers.splitQuery.call(void 0, {
              queryString: context.queryString,
              schema: await context.client.getSchema()
            });
          },
          onDone: {
            target: "ready",
            actions: _xstate.assign.call(void 0, {
              queries: (context, event) => {
                return event.data.queries;
              },
              fragments: (context, event) => {
                return event.data.fragments;
              }
            })
          },
          onError: "failure"
        }
      },
      ready: {
        entry: _xstate.assign.call(void 0, {
          formRef: (context) => _xstate.spawn.call(void 0, formCallback(context))
        }),
        on: {
          ON_FIELD_CHANGE: {
            actions: _xstate.sendParent.call(void 0, (context, event) => ({
              type: "FORM_VALUE_CHANGE",
              pathAndValue: event.values
            }))
          }
        }
      },
      failure: {
        entry: (c, e) => console.log("failed", e)
      }
    },
    context: {
      queryFieldName: initialContext.queryFieldName,
      queryString: initialContext.queryString,
      node: initialContext.node,
      cms: initialContext.cms,
      client: initialContext.client,
      queries: null,
      fragments: null,
      error: null,
      formRef: null,
      onSubmit: initialContext.onSubmit,
      formify: initialContext.formify
    }
  });
};
const buildFields = ({
  parentPath,
  form,
  context,
  callback
}) => {
  return form.fields.map((field) => {
    if (field.component === "group" || field.component === "group-list") {
      field.fields = buildFields({
        parentPath,
        form: field,
        context,
        callback
      });
    }
    if (field.component === "list") {
      field.field = __assign(__assign({}, field.field), {
        parse: buildParseFunction({
          parentPath,
          callback,
          context,
          field: field.field
        })
      });
    }
    if (field.component === "blocks") {
      const templateKeys = Object.keys(field.templates);
      Object.values(field.templates).map((template, index) => {
        field.templates[templateKeys[index]].fields = buildFields({
          parentPath,
          context,
          form: template,
          callback
        });
      });
    }
    return __assign(__assign({}, field), {
      parse: buildParseFunction({parentPath, context, field, callback})
    });
  });
};
const buildParseFunction = ({
  parentPath,
  context,
  field,
  callback
}) => {
  return (value, name) => {
    const queryPath = [...parentPath, ...name.split(".")].filter((item) => {
      return isNaN(parseInt(item));
    }).join(".");
    if (field.component === "select" && context.queries[queryPath]) {
      const queryObj = context.queries[queryPath];
      const frags = [];
      let uniqueFragments = [...new Set(queryObj.fragments)];
      uniqueFragments.forEach((fragment) => {
        frags.push(context.fragments.find((fr) => fr.name === fragment).fragment);
      });
      if (!value) {
        return;
      }
      context.client.request(`${frags.join("\n")}
${queryObj.query}`, {
        variables: {
          relativePath: value
        }
      }).then((res) => {
        callback({
          type: "ON_FIELD_CHANGE",
          values: {
            path: [...parentPath, ...name.split(".")],
            value: Object.values(res)[0]
          }
        });
      });
    } else {
      callback({
        type: "ON_FIELD_CHANGE",
        values: {
          path: [...parentPath, ...name.split(".")],
          value
        }
      });
    }
    return value;
  };
};
const formCallback = (context) => (callback, receive) => {
  const path = [context.queryFieldName, "data"];
  const fields = buildFields({
    parentPath: path,
    context,
    form: context.node.form,
    callback
  });
  const formConfig = {
    id: context.queryFieldName,
    label: context.node._internalSys.basename,
    fields,
    reset: () => {
      callback({
        type: "ON_FIELD_CHANGE",
        values: {
          path: [context.queryFieldName, "data"],
          value: context.node.initialData
        }
      });
    },
    initialValues: context.node.values,
    onSubmit: async (values) => {
      const queryForMutation = context.queries[context.queryFieldName];
      const mutation = queryForMutation.mutation;
      const frags = [];
      let uniqueFragments = [...new Set(queryForMutation.fragments)];
      uniqueFragments.forEach((fragment) => {
        frags.push(context.fragments.find((fr) => fr.name === fragment).fragment);
      });
      try {
        await context.onSubmit({
          mutationString: `${frags.join("\n")}
${mutation}
`,
          relativePath: context.node._internalSys.relativePath,
          values,
          sys: context.node._internalSys
        });
        context.cms.alerts.info("Document saved!");
      } catch (e) {
        context.cms.alerts.info(e.message);
      }
    }
  };
  const createForm = (formConfig2) => {
    const form2 = new (0, _tinacms.Form)(formConfig2);
    context.cms.plugins.add(form2);
    return form2;
  };
  let form;
  let skipped = false;
  const skip = () => {
    skipped = true;
  };
  if (context.formify) {
    form = context.formify({formConfig, createForm, skip});
  } else {
    form = createForm(formConfig);
  }
  if (skipped)
    return;
  if (!(form instanceof _tinacms.Form)) {
    throw new Error("formify must return a form or skip()");
  }
  fixMutators({context, form, callback});
  form.subscribe((all) => {
    callback({
      type: "ON_FIELD_CHANGE",
      values: {
        path: [context.queryFieldName, "values"],
        value: all.values
      }
    });
  }, {values: true});
  return () => context.cms.plugins.remove(form);
};

// src/hooks/create-page-plugin.ts
class ContentCreatorPlugin {
  constructor(options) {
    this.__type = "content-creator";
    this.fields = options.fields;
    this.name = options.label;
    this.onNewDocument = options.onNewDocument;
  }
  async onSubmit({collectionTemplate, relativePath}, cms) {
    const [collection, template] = collectionTemplate ? collectionTemplate.split(".") : this.fields.find((field) => field.name === "collectionTemplate").options[0].value.split(".");
    let relativePathWithExt = relativePath;
    if (relativePath.slice(-3).toLocaleLowerCase() === ".md") {
      relativePathWithExt = `${relativePath.slice(0, -3)}.md`;
    } else {
      relativePathWithExt = `${relativePath}.md`;
    }
    const payload = {
      relativePath: relativePathWithExt,
      collection,
      template
    };
    try {
      const res = await cms.api.tina.addPendingContent(payload);
      if (res.errors) {
        res.errors.map((e) => {
          cms.alerts.error(e.message);
        });
      } else {
        cms.alerts.info("Document created!");
        this.onNewDocument(res.addPendingDocument.sys);
      }
    } catch (e) {
      cms.alerts.error(e.message);
    }
  }
}

// src/hooks/use-graphql-forms.ts



var _react3 = require('@xstate/react');



const formsMachine = _xstate.createMachine.call(void 0, {
  id: "forms",
  initial: "inactive",
  states: {
    inactive: {
      on: {
        RETRY: {
          target: "initializing",
          actions: _xstate.assign.call(void 0, {
            payload: (context, event) => {
              return event.value.payload;
            },
            queryString: (context, event) => {
              return event.value.queryString;
            }
          })
        }
      }
    },
    initializing: {
      always: {
        target: "active",
        actions: _xstate.assign.call(void 0, {
          formRefs: (context, event) => {
            const accum = {};
            const keys = Object.keys(context.payload);
            Object.values(context.payload).forEach((item, index) => {
              if (!item.form)
                return;
              accum[keys[index]] = _xstate.spawn.call(void 0, createFormMachine({
                client: context.cms.api.tina,
                cms: context.cms,
                node: __assign(__assign({}, item), {
                  initialData: item.data
                }),
                onSubmit: context.onSubmit,
                queryFieldName: keys[index],
                queryString: context.queryString,
                formify: context.formify
              }), `form-${keys[index]}`);
            });
            return accum;
          }
        })
      }
    },
    active: {
      on: {
        FORM_VALUE_CHANGE: {
          actions: _xstate.assign.call(void 0, {
            payload: (context, event) => {
              return _finalform.setIn.call(void 0, context.payload, event.pathAndValue.path.join("."), event.pathAndValue.value);
            }
          })
        },
        RETRY: {
          target: "initializing",
          actions: _xstate.assign.call(void 0, {
            payload: (context, event) => {
              return event.value.payload;
            },
            queryString: (context, event) => {
              return event.value.queryString;
            }
          })
        }
      }
    }
  }
});
const useDocumentCreatorPlugin = (onNewDocument, filterCollections) => {
  const cms = _tinacms.useCMS.call(void 0, );
  _react2.default.useEffect(() => {
    const run = async () => {
      const getCollectionOptions = async () => {
        const res = await cms.api.tina.request((gql3) => gql3`
            {
              getCollections {
                label
                slug
              }
            }
          `, {variables: {}});
        const emptyOption = {value: "", label: "Choose Collection"};
        const options = [];
        res.getCollections.forEach((collection) => {
          const value = collection.slug;
          const label = `${collection.label}`;
          options.push({value, label});
        });
        if (filterCollections && typeof filterCollections === "function") {
          const filtered = filterCollections(options);
          return [emptyOption, ...filtered];
        }
        return [emptyOption, ...options];
      };
      const getCollectionTemplateOptions = async (collection) => {
        var _a, _b;
        if (!collection) {
          return [];
        }
        const res = await cms.api.tina.request((gql3) => gql3`
            query CollectionQuery($collection: String) {
              getCollection(collection: $collection) {
                templates
              }
            }
          `, {variables: {collection}});
        const options = [{value: "", label: "Choose Template"}];
        (_b = (_a = res.getCollection) == null ? void 0 : _a.templates) == null ? void 0 : _b.forEach((template) => {
          const value = `${collection}.${template}`;
          const label = `${template}`;
          options.push({value, label});
        });
        return options;
      };
      cms.plugins.add(new ContentCreatorPlugin({
        onNewDocument,
        fields: [
          {
            component: "select",
            name: "collection",
            label: "Collection",
            description: "Select the collection.",
            options: await getCollectionOptions(),
            validate: async (value) => {
              if (!value) {
                return "Required";
              }
            }
          },
          {
            component: "select",
            name: "collectionTemplate",
            label: "Template",
            description: "Select the template.",
            options: [],
            validate: async (value, allValues, meta, field) => {
              const collection = allValues == null ? void 0 : allValues.collection;
              const previousCollection = value ? value.split(".")[0] : void 0;
              if (!collection) {
                field.options = [];
                meta.change("");
                return "Required";
              }
              if (collection !== previousCollection) {
                field.options = await getCollectionTemplateOptions(collection);
                meta.change("");
                return "Required";
              }
              if (!value) {
                return "Required";
              }
            }
          },
          {
            component: "text",
            name: "relativePath",
            label: "Name",
            description: `A unique name for the content. Example: "newPost" or "blog_022021`,
            placeholder: "newPost",
            validate: (value) => {
              if (!value) {
                return "Required";
              }
              const isValid = /^[_a-zA-Z][_a-zA-Z0-9]*$/.test(value);
              if (value && !isValid) {
                return "Must begin with a-z, A-Z, or _ and contain only a-z, A-Z, 0-9, or _";
              }
            }
          }
        ],
        label: "Add Document"
      }));
    };
    run();
  }, [cms]);
};
function useRegisterFormsAndSyncPayload({
  queryString,
  onSubmit,
  formify: formify2
}) {
  const cms = _tinacms.useCMS.call(void 0, );
  const [tinaForms, setTinaForms] = _react2.default.useState([]);
  const [machineState, send, service] = _react3.useMachine.call(void 0, formsMachine, {
    context: {
      formRefs: {},
      cms,
      queryString,
      formify: formify2,
      onSubmit: async (values) => {
        const variables = await cms.api.tina.prepareVariables(values);
        return onSubmit ? onSubmit({
          queryString: values.mutationString,
          variables
        }) : cms.api.tina.request(values.mutationString, {variables}).then((res) => {
          if (res.errors) {
            console.error(res);
            cms.alerts.error("Unable to update document");
          }
        });
      }
    }
  });
  _react2.default.useEffect(() => {
    const subscription = service.subscribe((state) => {
      if (state.matches("active")) {
        const formIds = Object.keys(state.context.formRefs);
        const forms = state.context.cms.plugins.all("form").map((formPlugin) => {
          if (formIds.includes(formPlugin.name)) {
            return formPlugin;
          } else {
            return false;
          }
        }).filter(Boolean);
        setTinaForms(forms);
      }
    });
    return subscription.unsubscribe;
  }, [service, setTinaForms]);
  return {
    data: {
      payload: machineState.context.payload,
      tinaForms
    },
    retry: (payload, queryString2) => {
      send({type: "RETRY", value: {payload, queryString: queryString2}});
    },
    ready: machineState.matches("active")
  };
}
function useGraphqlForms({
  query,
  variables,
  onSubmit,
  formify: formify2 = null
}) {
  const cms = _tinacms.useCMS.call(void 0, );
  const queryString = _graphql.print.call(void 0, query(_graphqltag2.default));
  const {data, retry, ready} = useRegisterFormsAndSyncPayload({
    queryString,
    onSubmit,
    formify: formify2
  });
  _react2.default.useEffect(() => {
    cms.api.tina.requestWithForm(query, {variables}).then((payload) => {
      retry(payload, queryString);
    }).catch((e) => {
      console.error(e);
    });
  }, [queryString]);
  return [data.payload, !ready];
}

// src/index.ts
function graphql4(strings) {
  return strings[0];
}











exports.AuthWallInner = AuthWallInner; exports.Client = Client; exports.DEFAULT_LOCAL_TINA_GQL_SERVER_URL = DEFAULT_LOCAL_TINA_GQL_SERVER_URL; exports.ForestryMediaStore = ForestryMediaStore; exports.LocalClient = LocalClient; exports.TinaCloudAuthWall = TinaCloudAuthWall; exports.graphql = graphql4; exports.useDocumentCreatorPlugin = useDocumentCreatorPlugin; exports.useGraphqlForms = useGraphqlForms; exports.useTinaAuthRedirect = useTinaAuthRedirect;
